(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{335:function(a,t,s){"use strict";s.r(t);var v=s(10),_=Object(v.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"分布式基础之cap和base理论"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分布式基础之cap和base理论"}},[a._v("#")]),a._v(" 分布式基础之CAP和BASE理论")]),a._v(" "),t("h2",{attrs:{id:"cap理论"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cap理论"}},[a._v("#")]),a._v(" CAP理论")]),a._v(" "),t("p",[a._v("CAP是一个已经经过证实的理论：一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项，其中P是网络的特性，所以只能选择AP或者CP。")]),a._v(" "),t("h3",{attrs:{id:"一致性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一致性"}},[a._v("#")]),a._v(" 一致性")]),a._v(" "),t("p",[a._v("我们知道ACID中事务的一致性是指事务的执行不能破坏数据库数据的完整性和一致性，一个事务在执行前后，数据库都必须处于一致性状态。也就是说，事务的执行结果必须是使数据库从一个一致性状态转变到另一个一致性状态。")]),a._v(" "),t("p",[a._v("和ACID中的一致性不同，分布式环境中的一致性是指数据在多个副本之间是否能够保持一致的特性。")]),a._v(" "),t("p",[a._v("分布式系统中，数据一般会存在不同节点的副本中，如果对第一个节点的数据成功进行了更新操作，而第二个节点上的数据却没有得到相应更新，这时候读取第二个节点的数据依然是更新前的数据，即脏数据，这就是分布式系统数据不一致的情况。\n在分布式系统中，如果能够做到针对一个数据项的更新操作执行成功后，所有的用户都能读取到最新的值，那么这样的系统就被认为具有强一致性（或严格的一致性）。")]),a._v(" "),t("h3",{attrs:{id:"可用性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#可用性"}},[a._v("#")]),a._v(" 可用性")]),a._v(" "),t("p",[a._v("可用性是指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果，如果超过了这个时间范围，那么系统就被认为是不可用的。")]),a._v(" "),t("p",[a._v("“有限的时间内”是在系统的运行指标，不同系统会有差别。例如搜索引擎通常在0.5秒内需要给出用户检索结果。")]),a._v(" "),t("p",[a._v('“返回结果”是可用性的另一个重要指标，它要求系统完成对用户请求的处理后，返回一个正常的响应结果，要明确的反映出对请求处理的成功或失败。如果返回的结果是系统错误，比如"OutOfMemory"等报错信息，则认为此时系统是不可用的。')]),a._v(" "),t("h3",{attrs:{id:"分区容错性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分区容错性"}},[a._v("#")]),a._v(" 分区容错性")]),a._v(" "),t("p",[a._v("一个分布式系统中，节点组成的网络本来应该是连通的。然而可能因为某些故障，使得有些节点之间不连通了，整个网络就分成了几块区域，而数据就散布在了这些不连通的区域中，这就叫分区。")]),a._v(" "),t("p",[a._v("当你一个数据项只在一个节点中保存，那么分区出现后，和这个节点不连通的部分就访问不到这个数据了。这时分区就是无法容忍的。")]),a._v(" "),t("p",[a._v("提高分区容忍性的办法就是一个数据项复制到多个节点上，那么出现分区之后，这一数据项仍然能在其他区中读取，容忍性就提高了。然而，把数据复制到多个节点，就会带来一致性的问题，就是多个节点上面的数据可能是不一致的。要保证一致，每次写操作就都要等待全部节点写成功，而这等待又会带来可用性的问题。")]),a._v(" "),t("p",[a._v("总的来说就是，数据存在的节点越多，分区容忍性越高，但要复制更新的数据就越多，一致性就越难保证。为了保证一致性，更新所有节点数据所需要的时间就越长，可用性就会降低。")]),a._v(" "),t("h3",{attrs:{id:"面临的问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#面临的问题"}},[a._v("#")]),a._v(" 面临的问题")]),a._v(" "),t("p",[a._v("对于多数大型互联网应用的场景，主机众多、部署分散，而且现在的集群规模越来越大，所以节点故障、网络故障是常态，而且要保证服务可用性达到N个9，即保证P和A，舍弃C。")]),a._v(" "),t("h2",{attrs:{id:"base理论"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#base理论"}},[a._v("#")]),a._v(" BASE理论")]),a._v(" "),t("p",[a._v("BASE理论是对CAP理论的延伸，思想是即使无法做到强一致性（CAP的一致性就是强一致性），但可以采用适当的采取弱一致性，即最终一致性。")]),a._v(" "),t("p",[a._v("BASE是指基本可用（Basically Available）、软状态（ Soft State）、最终一致性（ Eventual Consistency）。")]),a._v(" "),t("h3",{attrs:{id:"基本可用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基本可用"}},[a._v("#")]),a._v(" 基本可用")]),a._v(" "),t("p",[a._v("基本可用是指分布式系统在出现故障的时候，允许损失部分可用性（例如响应时间、功能上的可用性），允许损失部分可用性。需要注意的是，基本可用绝不等价于系统不可用。")]),a._v(" "),t("p",[a._v("响应时间上的损失：正常情况下搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出现故障（比如系统部分机房发生断电或断网故障），查询结果的响应时间增加到了1~2秒。")]),a._v(" "),t("p",[a._v("功能上的损失：购物网站在购物高峰（如双十一）时，为了保护系统的稳定性，部分消费者可能会被引导到一个降级页面。")]),a._v(" "),t("h3",{attrs:{id:"软状态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#软状态"}},[a._v("#")]),a._v(" 软状态")]),a._v(" "),t("p",[a._v("软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据会有多个副本，允许不同副本同步的延时就是软状态的体现。mysql replication的异步复制也是一种体现。")]),a._v(" "),t("h3",{attrs:{id:"最终一致性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#最终一致性"}},[a._v("#")]),a._v(" 最终一致性")]),a._v(" "),t("p",[a._v("最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。")])])}),[],!1,null,null,null);t.default=_.exports}}]);