(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{331:function(t,a,_){"use strict";_.r(a);var e=_(10),v=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"rabbitmq简单使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq简单使用"}},[t._v("#")]),t._v(" RabbitMQ简单使用")]),t._v(" "),a("h2",{attrs:{id:"一、基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、基础"}},[t._v("#")]),t._v(" 一、基础")]),t._v(" "),a("h3",{attrs:{id:"_1-1是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-1是什么"}},[t._v("#")]),t._v(" 1.1是什么")]),t._v(" "),a("p",[t._v("RabbitMQ是一个开源的遵循AMQP协议实现的基于Erlang语言编写，支持多种客户端（语言）。用于在分布式系统中存储消息，转发消息，具有高可用，高可扩性，易用性等特征。")]),t._v(" "),a("h3",{attrs:{id:"_1-2命令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-2命令"}},[t._v("#")]),t._v(" 1.2命令")]),t._v(" "),a("h4",{attrs:{id:"常用命令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常用命令"}},[t._v("#")]),t._v(" 常用命令")]),t._v(" "),a("p",[t._v("启动服务")]),t._v(" "),a("blockquote",[a("p",[t._v("systemctl start rabbitmq-server")])]),t._v(" "),a("p",[t._v("重启服务")]),t._v(" "),a("blockquote",[a("p",[t._v("systemctl restart rabbitmq-server")])]),t._v(" "),a("p",[t._v("查看服务状态")]),t._v(" "),a("blockquote",[a("p",[t._v("systemctl status rabbitmq-server")])]),t._v(" "),a("p",[t._v("停止服务")]),t._v(" "),a("blockquote",[a("p",[t._v("systemctl stop rabbitmq-server")])]),t._v(" "),a("p",[t._v("开机启动服务")]),t._v(" "),a("blockquote",[a("p",[t._v("systemctl enable rabbitmq-server")])]),t._v(" "),a("p",[t._v("安装web控制台插件")]),t._v(" "),a("blockquote",[a("p",[t._v("rabbitmq-plugins enable rabbitmq_management")])]),t._v(" "),a("h4",{attrs:{id:"用户相关"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#用户相关"}},[t._v("#")]),t._v(" 用户相关")]),t._v(" "),a("blockquote",[a("p",[t._v('rabbitmqctl add_user 账号 密码\nrabbitmqctl set_user_tags 账号 administrator\nrabbitmqctl change_password Username Newpassword 修改密码\nrabbitmqctl delete_user Username 删除用户\nrabbitmqctl list_users 查看用户清单\nrabbitmqctl set_permissions -p / 用户名 ".'),a("em",[t._v('" ".')]),t._v('" ".'),a("em",[t._v('" 为用户设置administrator角色\nrabbitmqctl set_permissions -p / root ".')]),t._v('" ".'),a("em",[t._v('" ".')]),t._v('"')])]),t._v(" "),a("h4",{attrs:{id:"linux排查命令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#linux排查命令"}},[t._v("#")]),t._v(" linux排查命令")]),t._v(" "),a("blockquote",[a("p",[t._v("more xxx.log  查看日记信息\nnetstat -naop | grep 5672 查看端口是否被占用\nps -ef | grep 5672  查看进程\nsystemctl stop 服务")])]),t._v(" "),a("h4",{attrs:{id:"docker相关命令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#docker相关命令"}},[t._v("#")]),t._v(" docker相关命令")]),t._v(" "),a("p",[t._v("默认用户名密码guest")]),t._v(" "),a("blockquote",[a("p",[t._v("docker run -di --name=myrabbit -p 15672:15672 rabbitmq:management")])]),t._v(" "),a("p",[t._v("方式二 启动容器时命名为myrabbit，同时映射rabbitmq和宿主机的端口，并设置用户名和密码为admin")]),t._v(" "),a("blockquote",[a("p",[t._v("docker run -di --name myrabbit -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin -p 15672:15672 -p 5672:5672 -p 25672:25672 -p 61613:61613 -p 1883:1883 rabbitmq:management")])]),t._v(" "),a("h3",{attrs:{id:"_1-3角色分类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-3角色分类"}},[t._v("#")]),t._v(" 1.3角色分类")]),t._v(" "),a("h4",{attrs:{id:"none"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#none"}},[t._v("#")]),t._v(" none")]),t._v(" "),a("ul",[a("li",[t._v("不能访问management plugin")])]),t._v(" "),a("h4",{attrs:{id:"management-查看自己相关节点信息"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#management-查看自己相关节点信息"}},[t._v("#")]),t._v(" management：查看自己相关节点信息")]),t._v(" "),a("ul",[a("li",[t._v("列出自己可以通过AMQP登入的虚拟机")]),t._v(" "),a("li",[t._v("查看自己的虚拟机节点 virtual hosts的queues,exchanges和bindings信息")]),t._v(" "),a("li",[t._v("查看和关闭自己的channels和connections")]),t._v(" "),a("li",[t._v("查看有关自己的虚拟机节点virtual hosts的统计信息。包括其他用户在这个节点virtual hosts中的活动信息。")])]),t._v(" "),a("h4",{attrs:{id:"policymaker"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#policymaker"}},[t._v("#")]),t._v(" Policymaker")]),t._v(" "),a("ul",[a("li",[t._v("包含management所有权限")]),t._v(" "),a("li",[t._v("查看和创建和删除自己的virtual hosts所属的policies和parameters信息。")])]),t._v(" "),a("h4",{attrs:{id:"monitoring"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#monitoring"}},[t._v("#")]),t._v(" Monitoring")]),t._v(" "),a("ul",[a("li",[t._v("包含management所有权限")]),t._v(" "),a("li",[t._v("罗列出所有的virtual hosts，包括不能登录的virtual hosts。")]),t._v(" "),a("li",[t._v("查看其他用户的connections和channels信息")]),t._v(" "),a("li",[t._v("查看节点级别的数据如clustering和memory使用情况")]),t._v(" "),a("li",[t._v("查看所有的virtual hosts的全局统计信息。")])]),t._v(" "),a("h4",{attrs:{id:"administrator"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#administrator"}},[t._v("#")]),t._v(" Administrator")]),t._v(" "),a("ul",[a("li",[t._v("最高权限")]),t._v(" "),a("li",[t._v("可以创建和删除virtual hosts")]),t._v(" "),a("li",[t._v("可以查看，创建和删除users")]),t._v(" "),a("li",[t._v("查看创建permisssions")]),t._v(" "),a("li",[t._v("关闭所有用户的connections")])]),t._v(" "),a("h2",{attrs:{id:"二、核心组成部分"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、核心组成部分"}},[t._v("#")]),t._v(" 二、核心组成部分")]),t._v(" "),a("h3",{attrs:{id:"_2-1核心概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1核心概念"}},[t._v("#")]),t._v(" 2.1核心概念")]),t._v(" "),a("p",[a("strong",[t._v("Server")]),t._v("：又称Broker ,接受客户端的连接，实现AMQP实体服务。 安装rabbitmq-server\n"),a("strong",[t._v("Connection")]),t._v("：连接，应用程序与Broker的网络连接 TCP/IP/ 三次握手和四次挥手\n"),a("strong",[t._v("Channel")]),t._v("：网络信道，几乎所有的操作都在Channel中进行，Channel是进行消息读写的通道，客户端可以建立对各Channel，每个Channel代表一个会话任务。\n"),a("strong",[t._v("Message")]),t._v(" :消息：服务与应用程序之间传送的数据，由Properties和body组成，Properties可是对消息进行修饰，比如消息的优先级，延迟等高级特性，Body则就是消息体的内容。\n"),a("strong",[t._v("Virtual Host")]),t._v(" 虚拟地址，用于进行逻辑隔离，最上层的消息路由，一个虚拟主机理由可以有若干个Exhange和Queueu，同一个虚拟主机里面不能有相同名字的Exchange\n"),a("strong",[t._v("Exchange")]),t._v("：交换机，接受消息，根据路由键发送消息到绑定的队列。(==不具备消息存储的能力==)\n"),a("strong",[t._v("Bindings")]),t._v("：Exchange和Queue之间的虚拟连接，binding中可以保护多个routing key.\n"),a("strong",[t._v("Routing key")]),t._v("：是一个路由规则，虚拟机可以用它来确定如何路由一个特定消息。\n"),a("strong",[t._v("Queue")]),t._v("：队列：也成为Message Queue,消息队列，保存消息并将它们转发给消费者。")]),t._v(" "),a("h3",{attrs:{id:"_2-2运行流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-2运行流程"}},[t._v("#")]),t._v(" 2.2运行流程")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/mai-junxuan/Cloud-image/image/202209210532087.webp",alt:"img"}})]),t._v(" "),a("h2",{attrs:{id:"三、支持消息的模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、支持消息的模式"}},[t._v("#")]),t._v(" 三、支持消息的模式")]),t._v(" "),a("h3",{attrs:{id:"_1-简单模式-hello-world"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-简单模式-hello-world"}},[t._v("#")]),t._v(" 1. 简单模式(Hello World)")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/mai-junxuan/Cloud-image/image/202209210532104.png",alt:"img"}})]),t._v(" "),a("p",[t._v("做最简单的事情，一个生产者对应一个消费者，RabbitMQ相当于一个消息代理，负责将A的消息转发给B。")]),t._v(" "),a("p",[t._v("单生产者，单消费者，单队列。")]),t._v(" "),a("hr"),t._v(" "),a("p",[t._v("应用场景：")]),t._v(" "),a("blockquote",[a("p",[t._v("将发送的电子邮件放到消息队列，然后邮件服务在队列中获取邮件并发送给收件人。")])]),t._v(" "),a("h3",{attrs:{id:"_2-工作队列模式-work-queues"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-工作队列模式-work-queues"}},[t._v("#")]),t._v(" 2. 工作队列模式(Work queues)")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/mai-junxuan/Cloud-image/image/202209210532481.png",alt:"img"}})]),t._v(" "),a("p",[t._v("在多个消费者之间分配任务(竞争的消费者模式)，一个生产者对应多个消费者。")]),t._v(" "),a("p",[t._v("适用于资源密集型任务， 单个消费者处理不过来，需要多个消费者进行处理的场景。")]),t._v(" "),a("p",[t._v("单生产者，多消费者，单队列。")]),t._v(" "),a("hr"),t._v(" "),a("p",[t._v("应用场景：")]),t._v(" "),a("blockquote",[a("p",[t._v("一个订单的处理需要10s，有多个订单可以同时放到消息队列，")]),t._v(" "),a("p",[t._v("然后让多个消费者同时并行处理，而不是单个消费者的串行消费。")])]),t._v(" "),a("h3",{attrs:{id:"_3-发布订阅模式-publish-subscribe"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-发布订阅模式-publish-subscribe"}},[t._v("#")]),t._v(" 3. 发布订阅模式(Publish/Subscribe)")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/mai-junxuan/Cloud-image/image/202209210532573.png",alt:"img"}})]),t._v(" "),a("p",[t._v("一次向许多消费者发送消息，将消息将广播到所有的消费者。")]),t._v(" "),a("p",[t._v("单生产者，多消费者，多队列。")]),t._v(" "),a("p",[t._v("应用场景：")]),t._v(" "),a("blockquote",[a("p",[t._v("更新商品库存后需要通知多个缓存和多个数据库。")])]),t._v(" "),a("p",[t._v("结构如下：")]),t._v(" "),a("ul",[a("li",[t._v("一个fanout类型交换机扇出两个消息队列，分别为缓存消息队列、数据库消息队列")]),t._v(" "),a("li",[t._v("一个缓存消息队列对应着多个缓存消费者")]),t._v(" "),a("li",[t._v("一个数据库消息队列对应着多个数据库消费者")])]),t._v(" "),a("h3",{attrs:{id:"_4-路由模式-routing"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-路由模式-routing"}},[t._v("#")]),t._v(" 4. 路由模式(Routing)")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/mai-junxuan/Cloud-image/image/202209210532800.png",alt:"路由模式(Routing)"}})]),t._v(" "),a("p",[t._v("根据Routing Key有选择地接收消息。")]),t._v(" "),a("p",[t._v("多消费者，选择性多队列，每个队列通过routing key全文匹配。")]),t._v(" "),a("blockquote",[a("p",[t._v("发送消息到交换机并且要指定路由键(Routing key) 。\n消费者将队列绑定到交换机时需要指定路由key，仅消费指定路由key的消息。")])]),t._v(" "),a("p",[t._v("应用场景：")]),t._v(" "),a("blockquote",[a("p",[t._v("在商品库存中增加了1台iphone12，iphone12促销活动消费者指定routing key为iphone12 promote，\n只有此促销活动会接收到消息，其它促销活动不关心也不会消费此routing key的消息。")])]),t._v(" "),a("h3",{attrs:{id:"_5-主题模式-topics"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-主题模式-topics"}},[t._v("#")]),t._v(" 5. 主题模式(Topics)")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/mai-junxuan/Cloud-image/image/202209210532250.png",alt:"主题模式(Topics)"}})]),t._v(" "),a("p",[t._v("主题交换机方式接收消息，将routing key和模式进行匹配。")]),t._v(" "),a("p",[t._v("多消费者，选择性多队列，每个队列通过模式匹配。")]),t._v(" "),a("blockquote",[a("p",[t._v("队列需要绑定在一个模式上。\n#匹配一个词或多个词，*只匹配一个词。")])]),t._v(" "),a("p",[t._v("应用场景：")]),t._v(" "),a("blockquote",[a("p",[t._v("iphone促销活动可以接收主题为多种iPhone的消息，如iphone12、iphone13等。")])]),t._v(" "),a("h3",{attrs:{id:"_6-远程过程调用-rpc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-远程过程调用-rpc"}},[t._v("#")]),t._v(" 6. 远程过程调用(RPC)")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/mai-junxuan/Cloud-image/image/202209210532576.png",alt:"远程过程调用(RPC)"}})]),t._v(" "),a("p",[t._v("在远程计算机上运行功能并等待结果。")]),t._v(" "),a("p",[t._v("应用场景：")]),t._v(" "),a("blockquote",[a("p",[t._v("需要等待接口返回数据，如订单支付。")])]),t._v(" "),a("h3",{attrs:{id:"_7-发布者确认-publisher-confirms"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-发布者确认-publisher-confirms"}},[t._v("#")]),t._v(" 7. 发布者确认(Publisher Confirms)")]),t._v(" "),a("p",[t._v("与发布者进行可靠的发布确认，发布者确认是RabbitMQ扩展，可以实现可靠的发布。")]),t._v(" "),a("blockquote",[a("p",[t._v("在通道上启用发布者确认后，RabbitMQ将异步确认发送者发布的消息，这意味着它们已在服务器端处理。")])]),t._v(" "),a("p",[t._v("应用场景：")]),t._v(" "),a("blockquote",[a("p",[t._v("对于消息可靠性要求较高，比如钱包扣款。")])]),t._v(" "),a("h2",{attrs:{id:"四、rabbitmq的使用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四、rabbitmq的使用场景"}},[t._v("#")]),t._v(" 四、RabbitMQ的使用场景")]),t._v(" "),a("ol",[a("li",[t._v("异步执行")]),t._v(" "),a("li",[t._v("高内聚，低耦合")]),t._v(" "),a("li",[t._v("流量的削峰")]),t._v(" "),a("li",[t._v("分布式事务的可靠消费和可靠生产")]),t._v(" "),a("li",[t._v("索引、缓存、静态化处理的数据同步")]),t._v(" "),a("li",[t._v("流量监控")]),t._v(" "),a("li",[t._v("日志监控（ELK）")]),t._v(" "),a("li",[t._v("下单、订单分发、抢票")])]),t._v(" "),a("h2",{attrs:{id:"五、过期时间ttl"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#五、过期时间ttl"}},[t._v("#")]),t._v(" 五、过期时间TTL")]),t._v(" "),a("p",[t._v("过期时间TTL表示可以对消息设置预期的时间，在这个时间内都可以被消费者接收获取；过了之后消息将自动被删除。RabbitMQ可以对"),a("strong",[t._v("消息和队列")]),t._v("设置TTL。目前有两种方法可以设置。")]),t._v(" "),a("ul",[a("li",[t._v("第一种是把消息队列设置成过期类型的队列，web界面会有TTL标识。设置完过期时间后，此队列的所有消息到期后都会过期。如果绑定了死信队列，则会把过期的消息==移到==死信队列里面。")]),t._v(" "),a("li",[t._v("第二种是给单个消息设置过期。")]),t._v(" "),a("li",[t._v("如果上述两种方法同时使用，则消息的过期时间以两者之间==TTL较小==的那个数值为准。")])]),t._v(" "),a("p",[a("strong",[t._v("TTL标识")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/mai-junxuan/Cloud-image/image/202209210532420.webp",alt:"img"}})]),t._v(" "),a("h2",{attrs:{id:"六、死信队列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#六、死信队列"}},[t._v("#")]),t._v(" 六、死信队列")]),t._v(" "),a("p",[t._v("DLX，全称为Dead-Letter-Exchange , 可以称之为死信交换机。当消息在一个队列中变成死信(dead message)之后，它能被重新发送到另一个交换机中，这个交换机就是DLX ，绑定DLX的队列就称之为死信队列。消息变成死信的原因：")]),t._v(" "),a("ul",[a("li",[t._v("消息被拒绝")]),t._v(" "),a("li",[t._v("消息过期")]),t._v(" "),a("li",[t._v("队列达到最大长度")])]),t._v(" "),a("blockquote",[a("p",[t._v("DLX也是一个正常的交换机，和一般的交换机没有区别，它能在任何的队列上被指定，实际上就是设置某一个队列的属性。当这个队列中存在死信时，Rabbitmq就会自动地将这个消息重新发布到设置的DLX上去，进而被路由到另一个队列，即死信队列。要想使用死信队列，只需要在定义队列的时候设置队列参数 "),a("code",[t._v("x-dead-letter-exchange")]),t._v(" 指定交换机即可")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/mai-junxuan/Cloud-image/image/202209210532597.webp",alt:"img"}})])])}),[],!1,null,null,null);a.default=v.exports}}]);