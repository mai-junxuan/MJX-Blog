import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as t,c as n,a}from"./app-2Nmlc3aW.js";const i={},l=a(`<h1 id="mysql中的事务" tabindex="-1"><a class="header-anchor" href="#mysql中的事务"><span>MySQL中的事务</span></a></h1><h2 id="如何使用" tabindex="-1"><a class="header-anchor" href="#如何使用"><span>如何使用</span></a></h2><p>MySQL的服务层不管理事务，而是由下层的存储引擎实现。比如InnoDB。</p><p><strong>MySQL支持本地事务的语句：</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>START TRANSACTION | BEGIN [WORK] 
COMMIT [WORK] [AND [NO] CHAIN] [[NO] RELEASE] 
ROLLBACK [WORK] [AND [NO] CHAIN] [[NO] RELEASE] 
SET AUTOCOMMIT = {0 | 1}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>START TRANSACTION 或 BEGIN 语句：开始一项新的事务。</li><li>COMMIT 和 ROLLBACK：用来提交或者回滚事务。</li><li>CHAIN 和 RELEASE 子句：分别用来定义在事务提交或者回滚之后的操作，CHAIN 会立即启动一个新事物，并且和刚才的事务具有相同的隔离级别，RELEASE 则会断开和客户端的连接。</li><li>SET AUTOCOMMIT 可以修改当前连接的提交方式， 如果设置了 SET AUTOCOMMIT=0，则设置之后的所有事务都需要通过明确的命令进行提交或者回滚</li></ul><p><strong>事务使用注意点：</strong></p><ul><li>如果在锁表期间，用 start transaction 命令开始一个新事务，会造成一个隐含的 unlock tables 被执行。</li><li>在同一个事务中，最好不使用不同存储引擎的表，否则 ROLLBACK 时需要对非事 务类型的表进行特别的处理，因为 COMMIT、ROLLBACK 只能对事务类型的表进行提交和回滚。</li><li>和 Oracle 的事务管理相同，所有的 DDL 语句是不能回滚的，并且部分的 DDL 语句会造成隐式的提交。</li><li>在事务中可以通过定义 SAVEPOINT（例如：mysql&gt; savepoint test; 定义 savepoint，名称为 test），指定回滚事务的一个部分，但是不能指定提交事务的一个部分。对于复杂的应用，可以定义多个不同的 SAVEPOINT，满足不同的条件时，回滚 不同的 SAVEPOINT。需要注意的是，如果定义了相同名字的 SAVEPOINT，则后面定义的SAVEPOINT 会覆盖之前的定义。对于不再需要使用的 SAVEPOINT，可以通过 RELEASE SAVEPOINT 命令删除 SAVEPOINT， 删除后的 SAVEPOINT， 不能再执行 ROLLBACK TO SAVEPOINT命令。</li></ul><p><strong>自动提交（autocommit）：</strong> Mysql默认采用自动提交模式，可以通过设置autocommit变量来启用或禁用自动提交模式</p><ul><li><strong>隐式锁定</strong></li></ul><p>InnoDB在事务执行过程中，使用两阶段锁协议：</p><p>随时都可以执行锁定，InnoDB会根据隔离级别在需要的时候自动加锁；</p><p>锁只有在执行commit或者rollback的时候才会释放，并且所有的锁都是在<strong>同一时刻</strong>被释放。</p><ul><li><strong>显式锁定</strong></li></ul><p>InnoDB也支持通过特定的语句进行显示锁定（存储引擎层）：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>select ... lock in share mode //共享锁 
select ... for update //排他锁 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>MySQL Server层的显示锁定：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>lock table和unlock table
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="事务隔离级别" tabindex="-1"><a class="header-anchor" href="#事务隔离级别"><span><strong>事务隔离级别</strong></span></a></h2><p>SQL 标准定义了四种隔离级别，MySQL 全都支持。这四种隔离级别分别是：</p><ol><li>读未提交（READ UNCOMMITTED）</li><li>读提交 （READ COMMITTED）</li><li>可重复读 （REPEATABLE READ）</li><li>串行化 （SERIALIZABLE）</li></ol><p>从上往下，隔离强度逐渐增强，性能逐渐变差。采用哪种隔离级别要根据系统需求权衡决定，其中，<strong>可重复读</strong>是 MySQL 的默认级别。</p><p>事务隔离其实就是为了解决上面提到的脏读、不可重复读、幻读这几个问题，下面展示了 4 种隔离级别对这三个问题的解决程度。</p><p><img src="https://cdn.jsdelivr.net/gh/mai-junxuan/Cloud-image/image/202209071634546.png" alt="img"></p><h2 id="什么是acid" tabindex="-1"><a class="header-anchor" href="#什么是acid"><span>什么是ACID</span></a></h2><p>一个事务有四个基本特性，也就是我们常说的（ACID）：</p><ol><li><strong>Atomicity（原子性）</strong>：事务是一个不可分割的整体，事务内所有操作要么全做成功，要么全失败。</li><li><strong>Consistency（一致性）</strong>：务执行前后，数据从一个状态到另一个状态必须是一致的（A向B转账，不能出现A扣了钱，B却没收到）。</li><li><strong>Isolation（隔离性a）</strong>： 多个并发事务之间相互隔离，不能互相干扰。</li><li><strong>Durability（持久性）</strong>：事务完成后，对数据库的更改是永久保存的，不能回滚。</li></ol><h2 id="acid靠什么保证的呢" tabindex="-1"><a class="header-anchor" href="#acid靠什么保证的呢"><span>ACID靠什么保证的呢？</span></a></h2><p>以MySQL为例：</p><p><strong>A原子性</strong>由undo log日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql</p><p><strong>C一致性</strong>一般由代码层面来保证</p><p><strong>I隔离性</strong>由锁和MVCC来保证</p><p><strong>D持久性</strong>由内存+redo log来保证，mysql修改数据同时在内存和redo log记录这次操作，事务提交的时候通过redo log刷盘，宕机的时候可以从redo log恢复</p><h2 id="并发事务带来的问题" tabindex="-1"><a class="header-anchor" href="#并发事务带来的问题"><span><strong>并发事务带来的问题</strong></span></a></h2><ul><li>更新丢失（Lost Update）：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题 －－最后的更新覆盖了由其他事务所做的更新。例如，两个编辑人员制作了同一 文档的电子副本。每个编辑人员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。 最后保存其更改副本的编辑人员覆盖另一个编辑人员所做的更改。如果在一个编辑人员完成并提交事务之前，另一个编辑人员不能访问同 一文件，则可避免此问题。</li><li>脏读（Dirty Reads）：一个事务正在对一条记录做修改，在这个事务完成并提交前， 这条记录的数据就处于不一致状态； 这时， 另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做&quot;脏读&quot;。</li><li>不可重复读（Non-Repeatable Reads）：一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做“不可重复读” 。</li><li>幻读 （Phantom Reads）： 一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读” 。</li></ul><h2 id="幻读和不可重复读的区别" tabindex="-1"><a class="header-anchor" href="#幻读和不可重复读的区别"><span><strong>幻读和不可重复读的区别：</strong></span></a></h2><ul><li>不可重复读的重点是修改：在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样。（因为中间有其他事务提交了修改）</li><li>幻读的重点在于新增或者删除：在同一事务中，同样的条件,，第一次和第二次读出来的记录数不一样。（因为中间有其他事务提交了插入/删除）</li></ul>`,37),s=[l];function o(r,d){return t(),n("div",null,s)}const g=e(i,[["render",o],["__file","MySQL中的事务.html.vue"]]),m=JSON.parse('{"path":"/MySQL/MySQL%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1.html","title":"MySQL中的事务","lang":"zh-CN","frontmatter":{"description":"MySQL中的事务 如何使用 MySQL的服务层不管理事务，而是由下层的存储引擎实现。比如InnoDB。 MySQL支持本地事务的语句： START TRANSACTION 或 BEGIN 语句：开始一项新的事务。 COMMIT 和 ROLLBACK：用来提交或者回滚事务。 CHAIN 和 RELEASE 子句：分别用来定义在事务提交或者回滚之后的操作...","head":[["meta",{"property":"og:url","content":"https://maijunxuan.cn/MySQL/MySQL%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1.html"}],["meta",{"property":"og:site_name","content":"麦俊轩的博客"}],["meta",{"property":"og:title","content":"MySQL中的事务"}],["meta",{"property":"og:description","content":"MySQL中的事务 如何使用 MySQL的服务层不管理事务，而是由下层的存储引擎实现。比如InnoDB。 MySQL支持本地事务的语句： START TRANSACTION 或 BEGIN 语句：开始一项新的事务。 COMMIT 和 ROLLBACK：用来提交或者回滚事务。 CHAIN 和 RELEASE 子句：分别用来定义在事务提交或者回滚之后的操作..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.jsdelivr.net/gh/mai-junxuan/Cloud-image/image/202209071634546.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-06-13T21:01:35.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"MySQL中的事务"}],["meta",{"property":"article:author","content":"maijunxuan"}],["meta",{"property":"article:modified_time","content":"2023-06-13T21:01:35.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MySQL中的事务\\",\\"image\\":[\\"https://cdn.jsdelivr.net/gh/mai-junxuan/Cloud-image/image/202209071634546.png\\"],\\"dateModified\\":\\"2023-06-13T21:01:35.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"maijunxuan\\",\\"email\\":\\"maijunxuan0309@gmail.com\\"}]}"]]},"headers":[{"level":2,"title":"如何使用","slug":"如何使用","link":"#如何使用","children":[]},{"level":2,"title":"事务隔离级别","slug":"事务隔离级别","link":"#事务隔离级别","children":[]},{"level":2,"title":"什么是ACID","slug":"什么是acid","link":"#什么是acid","children":[]},{"level":2,"title":"ACID靠什么保证的呢？","slug":"acid靠什么保证的呢","link":"#acid靠什么保证的呢","children":[]},{"level":2,"title":"并发事务带来的问题","slug":"并发事务带来的问题","link":"#并发事务带来的问题","children":[]},{"level":2,"title":"幻读和不可重复读的区别：","slug":"幻读和不可重复读的区别","link":"#幻读和不可重复读的区别","children":[]}],"git":{"createdTime":1663601526000,"updatedTime":1686690095000,"contributors":[{"name":"MJX","email":"1585225345@qq.com","commits":3}]},"readingTime":{"minutes":5.69,"words":1708},"filePathRelative":"MySQL/MySQL中的事务.md","localizedDate":"2022年9月19日","excerpt":"\\n<h2>如何使用</h2>\\n<p>MySQL的服务层不管理事务，而是由下层的存储引擎实现。比如InnoDB。</p>\\n<p><strong>MySQL支持本地事务的语句：</strong></p>\\n<div class=\\"language-text\\" data-ext=\\"text\\" data-title=\\"text\\"><pre class=\\"language-text\\"><code>START TRANSACTION | BEGIN [WORK] \\nCOMMIT [WORK] [AND [NO] CHAIN] [[NO] RELEASE] \\nROLLBACK [WORK] [AND [NO] CHAIN] [[NO] RELEASE] \\nSET AUTOCOMMIT = {0 | 1}\\n</code></pre></div>","autoDesc":true}');export{g as comp,m as data};
