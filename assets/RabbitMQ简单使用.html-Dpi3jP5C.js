import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as t,c as a,a as i}from"./app-Digg1ELS.js";const n={},l=i('<h1 id="rabbitmq简单使用" tabindex="-1"><a class="header-anchor" href="#rabbitmq简单使用"><span>RabbitMQ简单使用</span></a></h1><h2 id="一、基础" tabindex="-1"><a class="header-anchor" href="#一、基础"><span>一、基础</span></a></h2><h3 id="_1-1是什么" tabindex="-1"><a class="header-anchor" href="#_1-1是什么"><span>1.1是什么</span></a></h3><p>RabbitMQ是一个开源的遵循AMQP协议实现的基于Erlang语言编写，支持多种客户端（语言）。用于在分布式系统中存储消息，转发消息，具有高可用，高可扩性，易用性等特征。</p><h3 id="_1-2命令" tabindex="-1"><a class="header-anchor" href="#_1-2命令"><span>1.2命令</span></a></h3><h4 id="常用命令" tabindex="-1"><a class="header-anchor" href="#常用命令"><span>常用命令</span></a></h4><p>启动服务</p><blockquote><p>systemctl start rabbitmq-server</p></blockquote><p>重启服务</p><blockquote><p>systemctl restart rabbitmq-server</p></blockquote><p>查看服务状态</p><blockquote><p>systemctl status rabbitmq-server</p></blockquote><p>停止服务</p><blockquote><p>systemctl stop rabbitmq-server</p></blockquote><p>开机启动服务</p><blockquote><p>systemctl enable rabbitmq-server</p></blockquote><p>安装web控制台插件</p><blockquote><p>rabbitmq-plugins enable rabbitmq_management</p></blockquote><h4 id="用户相关" tabindex="-1"><a class="header-anchor" href="#用户相关"><span>用户相关</span></a></h4><blockquote><p>rabbitmqctl add_user 账号 密码 rabbitmqctl set_user_tags 账号 administrator rabbitmqctl change_password Username Newpassword 修改密码 rabbitmqctl delete_user Username 删除用户 rabbitmqctl list_users 查看用户清单 rabbitmqctl set_permissions -p / 用户名 &quot;.<em>&quot; &quot;.</em>&quot; &quot;.<em>&quot; 为用户设置administrator角色 rabbitmqctl set_permissions -p / root &quot;.</em>&quot; &quot;.<em>&quot; &quot;.</em>&quot;</p></blockquote><h4 id="linux排查命令" tabindex="-1"><a class="header-anchor" href="#linux排查命令"><span>linux排查命令</span></a></h4><blockquote><p>more xxx.log 查看日记信息 netstat -naop | grep 5672 查看端口是否被占用 ps -ef | grep 5672 查看进程 systemctl stop 服务</p></blockquote><h4 id="docker相关命令" tabindex="-1"><a class="header-anchor" href="#docker相关命令"><span>docker相关命令</span></a></h4><p>默认用户名密码guest</p><blockquote><p>docker run -di --name=myrabbit -p 15672:15672 rabbitmq:management</p></blockquote><p>方式二 启动容器时命名为myrabbit，同时映射rabbitmq和宿主机的端口，并设置用户名和密码为admin</p><blockquote><p>docker run -di --name myrabbit -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin -p 15672:15672 -p 5672:5672 -p 25672:25672 -p 61613:61613 -p 1883:1883 rabbitmq:management</p></blockquote><h3 id="_1-3角色分类" tabindex="-1"><a class="header-anchor" href="#_1-3角色分类"><span>1.3角色分类</span></a></h3><h4 id="none" tabindex="-1"><a class="header-anchor" href="#none"><span>none</span></a></h4><ul><li>不能访问management plugin</li></ul><h4 id="management-查看自己相关节点信息" tabindex="-1"><a class="header-anchor" href="#management-查看自己相关节点信息"><span>management：查看自己相关节点信息</span></a></h4><ul><li>列出自己可以通过AMQP登入的虚拟机</li><li>查看自己的虚拟机节点 virtual hosts的queues,exchanges和bindings信息</li><li>查看和关闭自己的channels和connections</li><li>查看有关自己的虚拟机节点virtual hosts的统计信息。包括其他用户在这个节点virtual hosts中的活动信息。</li></ul><h4 id="policymaker" tabindex="-1"><a class="header-anchor" href="#policymaker"><span>Policymaker</span></a></h4><ul><li>包含management所有权限</li><li>查看和创建和删除自己的virtual hosts所属的policies和parameters信息。</li></ul><h4 id="monitoring" tabindex="-1"><a class="header-anchor" href="#monitoring"><span>Monitoring</span></a></h4><ul><li>包含management所有权限</li><li>罗列出所有的virtual hosts，包括不能登录的virtual hosts。</li><li>查看其他用户的connections和channels信息</li><li>查看节点级别的数据如clustering和memory使用情况</li><li>查看所有的virtual hosts的全局统计信息。</li></ul><h4 id="administrator" tabindex="-1"><a class="header-anchor" href="#administrator"><span>Administrator</span></a></h4><ul><li>最高权限</li><li>可以创建和删除virtual hosts</li><li>可以查看，创建和删除users</li><li>查看创建permisssions</li><li>关闭所有用户的connections</li></ul><h2 id="二、核心组成部分" tabindex="-1"><a class="header-anchor" href="#二、核心组成部分"><span>二、核心组成部分</span></a></h2><h3 id="_2-1核心概念" tabindex="-1"><a class="header-anchor" href="#_2-1核心概念"><span>2.1核心概念</span></a></h3><p><strong>Server</strong>：又称Broker ,接受客户端的连接，实现AMQP实体服务。 安装rabbitmq-server <strong>Connection</strong>：连接，应用程序与Broker的网络连接 TCP/IP/ 三次握手和四次挥手 <strong>Channel</strong>：网络信道，几乎所有的操作都在Channel中进行，Channel是进行消息读写的通道，客户端可以建立对各Channel，每个Channel代表一个会话任务。 <strong>Message</strong> :消息：服务与应用程序之间传送的数据，由Properties和body组成，Properties可是对消息进行修饰，比如消息的优先级，延迟等高级特性，Body则就是消息体的内容。 <strong>Virtual Host</strong> 虚拟地址，用于进行逻辑隔离，最上层的消息路由，一个虚拟主机理由可以有若干个Exhange和Queueu，同一个虚拟主机里面不能有相同名字的Exchange <strong>Exchange</strong>：交换机，接受消息，根据路由键发送消息到绑定的队列。(==不具备消息存储的能力==) <strong>Bindings</strong>：Exchange和Queue之间的虚拟连接，binding中可以保护多个routing key. <strong>Routing key</strong>：是一个路由规则，虚拟机可以用它来确定如何路由一个特定消息。 <strong>Queue</strong>：队列：也成为Message Queue,消息队列，保存消息并将它们转发给消费者。</p><h3 id="_2-2运行流程" tabindex="-1"><a class="header-anchor" href="#_2-2运行流程"><span>2.2运行流程</span></a></h3><p><img src="https://cdn.jsdelivr.net/gh/mai-junxuan/Cloud-image/image/202209210532087.webp" alt="img"></p><h2 id="三、支持消息的模式" tabindex="-1"><a class="header-anchor" href="#三、支持消息的模式"><span>三、支持消息的模式</span></a></h2><h3 id="_1-简单模式-hello-world" tabindex="-1"><a class="header-anchor" href="#_1-简单模式-hello-world"><span>1. 简单模式(Hello World)</span></a></h3><p><img src="https://cdn.jsdelivr.net/gh/mai-junxuan/Cloud-image/image/202209210532104.png" alt="img"></p><p>做最简单的事情，一个生产者对应一个消费者，RabbitMQ相当于一个消息代理，负责将A的消息转发给B。</p><p>单生产者，单消费者，单队列。</p><hr><p>应用场景：</p><blockquote><p>将发送的电子邮件放到消息队列，然后邮件服务在队列中获取邮件并发送给收件人。</p></blockquote><h3 id="_2-工作队列模式-work-queues" tabindex="-1"><a class="header-anchor" href="#_2-工作队列模式-work-queues"><span>2. 工作队列模式(Work queues)</span></a></h3><p><img src="https://cdn.jsdelivr.net/gh/mai-junxuan/Cloud-image/image/202209210532481.png" alt="img"></p><p>在多个消费者之间分配任务(竞争的消费者模式)，一个生产者对应多个消费者。</p><p>适用于资源密集型任务， 单个消费者处理不过来，需要多个消费者进行处理的场景。</p><p>单生产者，多消费者，单队列。</p><hr><p>应用场景：</p><blockquote><p>一个订单的处理需要10s，有多个订单可以同时放到消息队列，</p><p>然后让多个消费者同时并行处理，而不是单个消费者的串行消费。</p></blockquote><h3 id="_3-发布订阅模式-publish-subscribe" tabindex="-1"><a class="header-anchor" href="#_3-发布订阅模式-publish-subscribe"><span>3. 发布订阅模式(Publish/Subscribe)</span></a></h3><p><img src="https://cdn.jsdelivr.net/gh/mai-junxuan/Cloud-image/image/202209210532573.png" alt="img"></p><p>一次向许多消费者发送消息，将消息将广播到所有的消费者。</p><p>单生产者，多消费者，多队列。</p><p>应用场景：</p><blockquote><p>更新商品库存后需要通知多个缓存和多个数据库。</p></blockquote><p>结构如下：</p><ul><li>一个fanout类型交换机扇出两个消息队列，分别为缓存消息队列、数据库消息队列</li><li>一个缓存消息队列对应着多个缓存消费者</li><li>一个数据库消息队列对应着多个数据库消费者</li></ul><h3 id="_4-路由模式-routing" tabindex="-1"><a class="header-anchor" href="#_4-路由模式-routing"><span>4. 路由模式(Routing)</span></a></h3><p><img src="https://cdn.jsdelivr.net/gh/mai-junxuan/Cloud-image/image/202209210532800.png" alt="路由模式(Routing)"></p><p>根据Routing Key有选择地接收消息。</p><p>多消费者，选择性多队列，每个队列通过routing key全文匹配。</p><blockquote><p>发送消息到交换机并且要指定路由键(Routing key) 。 消费者将队列绑定到交换机时需要指定路由key，仅消费指定路由key的消息。</p></blockquote><p>应用场景：</p><blockquote><p>在商品库存中增加了1台iphone12，iphone12促销活动消费者指定routing key为iphone12 promote， 只有此促销活动会接收到消息，其它促销活动不关心也不会消费此routing key的消息。</p></blockquote><h3 id="_5-主题模式-topics" tabindex="-1"><a class="header-anchor" href="#_5-主题模式-topics"><span>5. 主题模式(Topics)</span></a></h3><p><img src="https://cdn.jsdelivr.net/gh/mai-junxuan/Cloud-image/image/202209210532250.png" alt="主题模式(Topics)"></p><p>主题交换机方式接收消息，将routing key和模式进行匹配。</p><p>多消费者，选择性多队列，每个队列通过模式匹配。</p><blockquote><p>队列需要绑定在一个模式上。 #匹配一个词或多个词，*只匹配一个词。</p></blockquote><p>应用场景：</p><blockquote><p>iphone促销活动可以接收主题为多种iPhone的消息，如iphone12、iphone13等。</p></blockquote><h3 id="_6-远程过程调用-rpc" tabindex="-1"><a class="header-anchor" href="#_6-远程过程调用-rpc"><span>6. 远程过程调用(RPC)</span></a></h3><p><img src="https://cdn.jsdelivr.net/gh/mai-junxuan/Cloud-image/image/202209210532576.png" alt="远程过程调用(RPC)"></p><p>在远程计算机上运行功能并等待结果。</p><p>应用场景：</p><blockquote><p>需要等待接口返回数据，如订单支付。</p></blockquote><h3 id="_7-发布者确认-publisher-confirms" tabindex="-1"><a class="header-anchor" href="#_7-发布者确认-publisher-confirms"><span>7. 发布者确认(Publisher Confirms)</span></a></h3><p>与发布者进行可靠的发布确认，发布者确认是RabbitMQ扩展，可以实现可靠的发布。</p><blockquote><p>在通道上启用发布者确认后，RabbitMQ将异步确认发送者发布的消息，这意味着它们已在服务器端处理。</p></blockquote><p>应用场景：</p><blockquote><p>对于消息可靠性要求较高，比如钱包扣款。</p></blockquote><h2 id="四、rabbitmq的使用场景" tabindex="-1"><a class="header-anchor" href="#四、rabbitmq的使用场景"><span>四、RabbitMQ的使用场景</span></a></h2><ol><li>异步执行</li><li>高内聚，低耦合</li><li>流量的削峰</li><li>分布式事务的可靠消费和可靠生产</li><li>索引、缓存、静态化处理的数据同步</li><li>流量监控</li><li>日志监控（ELK）</li><li>下单、订单分发、抢票</li></ol><h2 id="五、过期时间ttl" tabindex="-1"><a class="header-anchor" href="#五、过期时间ttl"><span>五、过期时间TTL</span></a></h2><p>过期时间TTL表示可以对消息设置预期的时间，在这个时间内都可以被消费者接收获取；过了之后消息将自动被删除。RabbitMQ可以对<strong>消息和队列</strong>设置TTL。目前有两种方法可以设置。</p><ul><li>第一种是把消息队列设置成过期类型的队列，web界面会有TTL标识。设置完过期时间后，此队列的所有消息到期后都会过期。如果绑定了死信队列，则会把过期的消息==移到==死信队列里面。</li><li>第二种是给单个消息设置过期。</li><li>如果上述两种方法同时使用，则消息的过期时间以两者之间==TTL较小==的那个数值为准。</li></ul><p><strong>TTL标识</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mai-junxuan/Cloud-image/image/202209210532420.webp" alt="img"></p><h2 id="六、死信队列" tabindex="-1"><a class="header-anchor" href="#六、死信队列"><span>六、死信队列</span></a></h2><p>DLX，全称为Dead-Letter-Exchange , 可以称之为死信交换机。当消息在一个队列中变成死信(dead message)之后，它能被重新发送到另一个交换机中，这个交换机就是DLX ，绑定DLX的队列就称之为死信队列。消息变成死信的原因：</p><ul><li>消息被拒绝</li><li>消息过期</li><li>队列达到最大长度</li></ul><blockquote><p>DLX也是一个正常的交换机，和一般的交换机没有区别，它能在任何的队列上被指定，实际上就是设置某一个队列的属性。当这个队列中存在死信时，Rabbitmq就会自动地将这个消息重新发布到设置的DLX上去，进而被路由到另一个队列，即死信队列。要想使用死信队列，只需要在定义队列的时候设置队列参数 <code>x-dead-letter-exchange</code> 指定交换机即可</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mai-junxuan/Cloud-image/image/202209210532597.webp" alt="img"></p>',103),s=[l];function r(o,p){return t(),a("div",null,s)}const u=e(n,[["render",r],["__file","RabbitMQ简单使用.html.vue"]]),b=JSON.parse('{"path":"/%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/RabbitMQ%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.html","title":"RabbitMQ简单使用","lang":"zh-CN","frontmatter":{"description":"RabbitMQ简单使用 一、基础 1.1是什么 RabbitMQ是一个开源的遵循AMQP协议实现的基于Erlang语言编写，支持多种客户端（语言）。用于在分布式系统中存储消息，转发消息，具有高可用，高可扩性，易用性等特征。 1.2命令 常用命令 启动服务 systemctl start rabbitmq-server 重启服务 systemctl r...","head":[["meta",{"property":"og:url","content":"https://maijunxuan.cn/%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/RabbitMQ%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.html"}],["meta",{"property":"og:site_name","content":"麦俊轩的博客"}],["meta",{"property":"og:title","content":"RabbitMQ简单使用"}],["meta",{"property":"og:description","content":"RabbitMQ简单使用 一、基础 1.1是什么 RabbitMQ是一个开源的遵循AMQP协议实现的基于Erlang语言编写，支持多种客户端（语言）。用于在分布式系统中存储消息，转发消息，具有高可用，高可扩性，易用性等特征。 1.2命令 常用命令 启动服务 systemctl start rabbitmq-server 重启服务 systemctl r..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.jsdelivr.net/gh/mai-junxuan/Cloud-image/image/202209210532087.webp"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-06-13T21:01:35.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"RabbitMQ简单使用"}],["meta",{"property":"article:author","content":"maijunxuan"}],["meta",{"property":"article:modified_time","content":"2023-06-13T21:01:35.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"RabbitMQ简单使用\\",\\"image\\":[\\"https://cdn.jsdelivr.net/gh/mai-junxuan/Cloud-image/image/202209210532087.webp\\",\\"https://cdn.jsdelivr.net/gh/mai-junxuan/Cloud-image/image/202209210532104.png\\",\\"https://cdn.jsdelivr.net/gh/mai-junxuan/Cloud-image/image/202209210532481.png\\",\\"https://cdn.jsdelivr.net/gh/mai-junxuan/Cloud-image/image/202209210532573.png\\",\\"https://cdn.jsdelivr.net/gh/mai-junxuan/Cloud-image/image/202209210532800.png\\",\\"https://cdn.jsdelivr.net/gh/mai-junxuan/Cloud-image/image/202209210532250.png\\",\\"https://cdn.jsdelivr.net/gh/mai-junxuan/Cloud-image/image/202209210532576.png\\",\\"https://cdn.jsdelivr.net/gh/mai-junxuan/Cloud-image/image/202209210532420.webp\\",\\"https://cdn.jsdelivr.net/gh/mai-junxuan/Cloud-image/image/202209210532597.webp\\"],\\"dateModified\\":\\"2023-06-13T21:01:35.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"maijunxuan\\"}]}"]]},"headers":[{"level":2,"title":"一、基础","slug":"一、基础","link":"#一、基础","children":[{"level":3,"title":"1.1是什么","slug":"_1-1是什么","link":"#_1-1是什么","children":[]},{"level":3,"title":"1.2命令","slug":"_1-2命令","link":"#_1-2命令","children":[]},{"level":3,"title":"1.3角色分类","slug":"_1-3角色分类","link":"#_1-3角色分类","children":[]}]},{"level":2,"title":"二、核心组成部分","slug":"二、核心组成部分","link":"#二、核心组成部分","children":[{"level":3,"title":"2.1核心概念","slug":"_2-1核心概念","link":"#_2-1核心概念","children":[]},{"level":3,"title":"2.2运行流程","slug":"_2-2运行流程","link":"#_2-2运行流程","children":[]}]},{"level":2,"title":"三、支持消息的模式","slug":"三、支持消息的模式","link":"#三、支持消息的模式","children":[{"level":3,"title":"1. 简单模式(Hello World)","slug":"_1-简单模式-hello-world","link":"#_1-简单模式-hello-world","children":[]},{"level":3,"title":"2. 工作队列模式(Work queues)","slug":"_2-工作队列模式-work-queues","link":"#_2-工作队列模式-work-queues","children":[]},{"level":3,"title":"3. 发布订阅模式(Publish/Subscribe)","slug":"_3-发布订阅模式-publish-subscribe","link":"#_3-发布订阅模式-publish-subscribe","children":[]},{"level":3,"title":"4. 路由模式(Routing)","slug":"_4-路由模式-routing","link":"#_4-路由模式-routing","children":[]},{"level":3,"title":"5. 主题模式(Topics)","slug":"_5-主题模式-topics","link":"#_5-主题模式-topics","children":[]},{"level":3,"title":"6. 远程过程调用(RPC)","slug":"_6-远程过程调用-rpc","link":"#_6-远程过程调用-rpc","children":[]},{"level":3,"title":"7. 发布者确认(Publisher Confirms)","slug":"_7-发布者确认-publisher-confirms","link":"#_7-发布者确认-publisher-confirms","children":[]}]},{"level":2,"title":"四、RabbitMQ的使用场景","slug":"四、rabbitmq的使用场景","link":"#四、rabbitmq的使用场景","children":[]},{"level":2,"title":"五、过期时间TTL","slug":"五、过期时间ttl","link":"#五、过期时间ttl","children":[]},{"level":2,"title":"六、死信队列","slug":"六、死信队列","link":"#六、死信队列","children":[]}],"git":{"createdTime":1663709749000,"updatedTime":1686690095000,"contributors":[{"name":"MJX","email":"1585225345@qq.com","commits":3}]},"readingTime":{"minutes":7.55,"words":2264},"filePathRelative":"中间件/RabbitMQ/RabbitMQ简单使用.md","localizedDate":"2022年9月20日","excerpt":"\\n<h2>一、基础</h2>\\n<h3>1.1是什么</h3>\\n<p>RabbitMQ是一个开源的遵循AMQP协议实现的基于Erlang语言编写，支持多种客户端（语言）。用于在分布式系统中存储消息，转发消息，具有高可用，高可扩性，易用性等特征。</p>\\n<h3>1.2命令</h3>\\n<h4>常用命令</h4>\\n<p>启动服务</p>\\n<blockquote>\\n<p>systemctl start rabbitmq-server</p>\\n</blockquote>\\n<p>重启服务</p>\\n<blockquote>\\n<p>systemctl restart rabbitmq-server</p>\\n</blockquote>","autoDesc":true}');export{u as comp,b as data};
