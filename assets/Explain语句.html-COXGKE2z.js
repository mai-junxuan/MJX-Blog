import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as t,c as l,a as n}from"./app-DITNE2eT.js";const i={},a=n(`<h1 id="explain语句" tabindex="-1"><a class="header-anchor" href="#explain语句"><span>Explain语句</span></a></h1><h2 id="explain使用" tabindex="-1"><a class="header-anchor" href="#explain使用"><span>EXPLAIN使用</span></a></h2><p>explain可用来分析SQL的执行计划。格式如下：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>{EXPLAIN | DESCRIBE | DESC}
    tbl_name [col_name | wild]

{EXPLAIN | DESCRIBE | DESC}
    [explain_type]
    {explainable_stmt | FOR CONNECTION connection_id}

{EXPLAIN | DESCRIBE | DESC} ANALYZE select_statement    

explain_type: {
    FORMAT = format_name
}

format_name: {
    TRADITIONAL
  | JSON
  | TREE
}

explainable_stmt: {
    SELECT statement
  | TABLE statement
  | DELETE statement
  | INSERT statement
  | REPLACE statement
  | UPDATE statement
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果输出展示：</p><table><thead><tr><th style="text-align:left;">字段</th><th style="text-align:left;">format=json时的名称</th><th style="text-align:left;">含义</th></tr></thead><tbody><tr><td style="text-align:left;">id</td><td style="text-align:left;">select_id</td><td style="text-align:left;">该语句的唯一标识</td></tr><tr><td style="text-align:left;">select_type</td><td style="text-align:left;">无</td><td style="text-align:left;">查询类型</td></tr><tr><td style="text-align:left;">table</td><td style="text-align:left;">table_name</td><td style="text-align:left;">表名</td></tr><tr><td style="text-align:left;">partitions</td><td style="text-align:left;">partitions</td><td style="text-align:left;">匹配的分区</td></tr><tr><td style="text-align:left;"><strong>type</strong></td><td style="text-align:left;">access_type</td><td style="text-align:left;">联接类型</td></tr><tr><td style="text-align:left;"><strong>possible_keys</strong></td><td style="text-align:left;">possible_keys</td><td style="text-align:left;">可能的索引选择</td></tr><tr><td style="text-align:left;"><strong>key</strong></td><td style="text-align:left;">key</td><td style="text-align:left;">实际选择的索引</td></tr><tr><td style="text-align:left;"><strong>key_len</strong></td><td style="text-align:left;">key_length</td><td style="text-align:left;">索引的长度</td></tr><tr><td style="text-align:left;">ref</td><td style="text-align:left;">ref</td><td style="text-align:left;">索引的哪一列被引用了</td></tr><tr><td style="text-align:left;"><strong>rows</strong></td><td style="text-align:left;">rows</td><td style="text-align:left;">估计要扫描的行</td></tr><tr><td style="text-align:left;"><strong>filtered</strong></td><td style="text-align:left;">filtered</td><td style="text-align:left;">表示符合查询条件的数据百分比</td></tr><tr><td style="text-align:left;"><strong>Extra</strong></td><td style="text-align:left;">没有</td><td style="text-align:left;">附加信息</td></tr></tbody></table><h2 id="结果解读" tabindex="-1"><a class="header-anchor" href="#结果解读"><span>结果解读</span></a></h2><h3 id="id" tabindex="-1"><a class="header-anchor" href="#id"><span>id</span></a></h3><p>该语句的唯一标识。如果explain的结果包括多个id值，则数字越大越先执行；而对于相同id的行，则表示从上往下依次执行。</p><h3 id="select-type" tabindex="-1"><a class="header-anchor" href="#select-type"><span>select_type</span></a></h3><p>查询类型，有如下几种取值：</p><table><thead><tr><th style="text-align:left;">查询类型</th><th style="text-align:left;">作用</th></tr></thead><tbody><tr><td style="text-align:left;">SIMPLE</td><td style="text-align:left;">简单查询（未使用UNION或子查询）</td></tr><tr><td style="text-align:left;">PRIMARY</td><td style="text-align:left;">最外层的查询</td></tr><tr><td style="text-align:left;">UNION</td><td style="text-align:left;">在UNION中的第二个和随后的SELECT被标记为UNION。如果UNION被FROM子句中的子查询包含，那么它的第一个SELECT会被标记为DERIVED。</td></tr><tr><td style="text-align:left;">DEPENDENT UNION</td><td style="text-align:left;">UNION中的第二个或后面的查询，依赖了外面的查询</td></tr><tr><td style="text-align:left;">UNION RESULT</td><td style="text-align:left;">UNION的结果</td></tr><tr><td style="text-align:left;">SUBQUERY</td><td style="text-align:left;">子查询中的第一个 SELECT</td></tr><tr><td style="text-align:left;">DEPENDENT SUBQUERY</td><td style="text-align:left;">子查询中的第一个 SELECT，依赖了外面的查询</td></tr><tr><td style="text-align:left;">DERIVED</td><td style="text-align:left;">用来表示包含在FROM子句的子查询中的SELECT，MySQL会递归执行并将结果放到一个临时表中。MySQL内部将其称为是Derived table（派生表），因为该临时表是从子查询派生出来的</td></tr><tr><td style="text-align:left;">DEPENDENT DERIVED</td><td style="text-align:left;">派生表，依赖了其他的表</td></tr><tr><td style="text-align:left;">MATERIALIZED</td><td style="text-align:left;">物化子查询</td></tr><tr><td style="text-align:left;">UNCACHEABLE SUBQUERY</td><td style="text-align:left;">子查询，结果无法缓存，必须针对外部查询的每一行重新评估</td></tr><tr><td style="text-align:left;">UNCACHEABLE UNION</td><td style="text-align:left;">UNION属于UNCACHEABLE SUBQUERY的第二个或后面的查询</td></tr></tbody></table><h3 id="table" tabindex="-1"><a class="header-anchor" href="#table"><span>table</span></a></h3><p>表示当前这一行正在访问哪张表，如果SQL定义了别名，则展示表的别名</p><h3 id="partitions" tabindex="-1"><a class="header-anchor" href="#partitions"><span>partitions</span></a></h3><p>当前查询匹配记录的分区。对于未分区的表，返回null</p><h3 id="type" tabindex="-1"><a class="header-anchor" href="#type"><span>type</span></a></h3><p>连接类型，有如下几种取值，<strong>性能从好到坏排序</strong> 如下：</p><ul><li><p>system：该表只有一行（相当于系统表），system是const类型的特例</p></li><li><p>const：针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可</p></li><li><p>eq_ref：当使用了索引的全部组成部分，并且索引是PRIMARY KEY或UNIQUE NOT NULL 才会使用该类型，性能仅次于system及const。</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>-- 多表关联查询，单行匹配
SELECT * FROM ref_table,other_table
  WHERE ref_table.key_column=other_table.column;

-- 多表关联查询，联合索引，多行匹配
SELECT * FROM ref_table,other_table
  WHERE ref_table.key_column_part1=other_table.column
  AND ref_table.key_column_part2=1;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>ref：当满足索引的最左前缀规则，或者索引不是主键也不是唯一索引时才会发生。如果使用的索引只会匹配到少量的行，性能也是不错的。</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>-- 根据索引（非主键，非唯一索引），匹配到多行
SELECT * FROM ref_table WHERE key_column=expr;

-- 多表关联查询，单个索引，多行匹配
SELECT * FROM ref_table,other_table
  WHERE ref_table.key_column=other_table.column;

-- 多表关联查询，联合索引，多行匹配
SELECT * FROM ref_table,other_table
  WHERE ref_table.key_column_part1=other_table.column
  AND ref_table.key_column_part2=1;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><strong>TIPS</strong></p><p>最左前缀原则，指的是索引按照最左优先的方式匹配索引。比如创建了一个组合索引(column1, column2, column3)，那么，如果查询条件是：</p><ul><li>WHERE column1 = 1、WHERE column1= 1 AND column2 = 2、WHERE column1= 1 AND column2 = 2 AND column3 = 3 都可以使用该索引；</li><li>WHERE column1 = 2、WHERE column1 = 1 AND column3 = 3就无法匹配该索引。</li></ul></blockquote></li><li><p>fulltext：全文索引</p></li><li><p>ref_or_null：该类型类似于ref，但是MySQL会额外搜索哪些行包含了NULL。这种类型常见于解析子查询</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>SELECT * FROM ref_table
  WHERE key_column=expr OR key_column IS NULL;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>index_merge：此类型表示使用了索引合并优化，表示一个查询里面用到了多个索引</p></li><li><p>unique_subquery：该类型和eq_ref类似，但是使用了IN查询，且子查询是主键或者唯一索引。例如：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>value IN (SELECT primary_key FROM single_table WHERE some_expr)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>index_subquery：和unique_subquery类似，只是子查询使用的是非唯一索引</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>value IN (SELECT key_column FROM single_table WHERE some_expr)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>range：范围扫描，表示检索了指定范围的行，主要用于有限制的索引扫描。比较常见的范围扫描是带有BETWEEN子句或WHERE子句里有&gt;、&gt;=、&lt;、&lt;=、IS NULL、&lt;=&gt;、BETWEEN、LIKE、IN()等操作符。</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>SELECT * FROM tbl_name
  WHERE key_column BETWEEN 10 and 20;

SELECT * FROM tbl_name
  WHERE key_column IN (10,20,30);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>index：全索引扫描，和ALL类似，只不过index是全盘扫描了索引的数据。当查询仅使用索引中的一部分列时，可使用此类型。有两种场景会触发：</p><ul><li>如果索引是查询的覆盖索引，并且索引查询的数据就可以满足查询中所需的所有数据，则只扫描索引树。此时，explain的Extra 列的结果是Using index。index通常比ALL快，因为索引的大小通常小于表数据。</li><li>按索引的顺序来查找数据行，执行了全表扫描。此时，explain的Extra列的结果不会出现Uses index。</li></ul></li><li><p>ALL：全表扫描，性能最差。</p></li></ul><h3 id="possible-keys" tabindex="-1"><a class="header-anchor" href="#possible-keys"><span>possible_keys</span></a></h3><p>展示当前查询可以使用哪些索引，这一列的数据是在优化过程的早期创建的，因此有些索引可能对于后续优化过程是没用的。</p><h3 id="key" tabindex="-1"><a class="header-anchor" href="#key"><span>key</span></a></h3><p>表示MySQL实际选择的索引</p><h3 id="key-len" tabindex="-1"><a class="header-anchor" href="#key-len"><span>key_len</span></a></h3><p>索引使用的字节数。由于存储格式，当字段允许为NULL时，key_len比不允许为空时大1字节。</p><h3 id="ref" tabindex="-1"><a class="header-anchor" href="#ref"><span>ref</span></a></h3><p>表示将哪个字段或常量和key列所使用的字段进行比较。</p><p>如果ref是一个函数，则使用的值是函数的结果。要想查看是哪个函数，可在EXPLAIN语句之后紧跟一个SHOW WARNING语句。</p><h3 id="rows" tabindex="-1"><a class="header-anchor" href="#rows"><span>rows</span></a></h3><p>MySQL估算会扫描的行数，数值越小越好。</p><h3 id="filtered" tabindex="-1"><a class="header-anchor" href="#filtered"><span>filtered</span></a></h3><p>表示符合查询条件的数据百分比，最大100。用rows × filtered可获得和下一张表连接的行数。例如rows = 1000，filtered = 50%，则和下一张表连接的行数是500。</p><h3 id="extra" tabindex="-1"><a class="header-anchor" href="#extra"><span>Extra</span></a></h3><p>展示有关本次查询的附加信息，取值如下：</p><ul><li><p><strong>Using <strong>filesort</strong></strong></p><p>当Query 中包含 ORDER BY 操作，而且无法利用索引完成排序操作的时候，MySQL Query Optimizer 不得不选择相应的排序算法来实现。数据较少时从内存排序，否则从磁盘排序。Explain不会显示的告诉客户端用哪种排序。官方解释：“MySQL需要额外的一次传递，以找出如何按排序顺序检索行。通过根据联接类型浏览所有行并为所有匹配WHERE子句的行保存排序关键字和行的指针来完成排序。然后关键字被排序，并按排序顺序检索行”</p></li><li><p>Using index</p><p>仅使用索引树中的信息从表中检索列信息，而不必进行其他查找以读取实际行。当查询仅使用属于单个索引的列时，可以使用此策略。例如：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>explain SELECT id FROM t
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>Using temporary</p><p>为了解决该查询，MySQL需要创建一个临时表来保存结果。如果查询包含不同列的GROUP BY和 ORDER BY子句，通常会发生这种情况。</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>-- name无索引
explain SELECT name FROM t1 group by name
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>Using where</p><p>如果我们不是读取表的所有数据，或者不是仅仅通过索引就可以获取所有需要的数据，则会出现using where信息</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>explain SELECT * FROM t1 where id &gt; 5
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ul>`,35),s=[a];function d(r,c){return t(),l("div",null,s)}const m=e(i,[["render",d],["__file","Explain语句.html.vue"]]),x=JSON.parse('{"path":"/MySQL/Explain%E8%AF%AD%E5%8F%A5.html","title":"Explain语句","lang":"zh-CN","frontmatter":{"description":"Explain语句 EXPLAIN使用 explain可用来分析SQL的执行计划。格式如下： 结果输出展示： 结果解读 id 该语句的唯一标识。如果explain的结果包括多个id值，则数字越大越先执行；而对于相同id的行，则表示从上往下依次执行。 select_type 查询类型，有如下几种取值： table 表示当前这一行正在访问哪张表，如果SQL...","head":[["meta",{"property":"og:url","content":"https://maijunxuan.cn/MySQL/Explain%E8%AF%AD%E5%8F%A5.html"}],["meta",{"property":"og:site_name","content":"麦俊轩的博客"}],["meta",{"property":"og:title","content":"Explain语句"}],["meta",{"property":"og:description","content":"Explain语句 EXPLAIN使用 explain可用来分析SQL的执行计划。格式如下： 结果输出展示： 结果解读 id 该语句的唯一标识。如果explain的结果包括多个id值，则数字越大越先执行；而对于相同id的行，则表示从上往下依次执行。 select_type 查询类型，有如下几种取值： table 表示当前这一行正在访问哪张表，如果SQL..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2022-09-19T15:32:06.000Z"}],["meta",{"property":"article:author","content":"maijunxuan"}],["meta",{"property":"article:modified_time","content":"2022-09-19T15:32:06.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Explain语句\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2022-09-19T15:32:06.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"maijunxuan\\"}]}"]]},"headers":[{"level":2,"title":"EXPLAIN使用","slug":"explain使用","link":"#explain使用","children":[]},{"level":2,"title":"结果解读","slug":"结果解读","link":"#结果解读","children":[{"level":3,"title":"id","slug":"id","link":"#id","children":[]},{"level":3,"title":"select_type","slug":"select-type","link":"#select-type","children":[]},{"level":3,"title":"table","slug":"table","link":"#table","children":[]},{"level":3,"title":"partitions","slug":"partitions","link":"#partitions","children":[]},{"level":3,"title":"type","slug":"type","link":"#type","children":[]},{"level":3,"title":"possible_keys","slug":"possible-keys","link":"#possible-keys","children":[]},{"level":3,"title":"key","slug":"key","link":"#key","children":[]},{"level":3,"title":"key_len","slug":"key-len","link":"#key-len","children":[]},{"level":3,"title":"ref","slug":"ref","link":"#ref","children":[]},{"level":3,"title":"rows","slug":"rows","link":"#rows","children":[]},{"level":3,"title":"filtered","slug":"filtered","link":"#filtered","children":[]},{"level":3,"title":"Extra","slug":"extra","link":"#extra","children":[]}]}],"git":{"createdTime":1663601526000,"updatedTime":1663601526000,"contributors":[{"name":"MJX","email":"1585225345@qq.com","commits":1}]},"readingTime":{"minutes":6.43,"words":1928},"filePathRelative":"MySQL/Explain语句.md","localizedDate":"2022年9月19日","excerpt":"\\n<h2>EXPLAIN使用</h2>\\n<p>explain可用来分析SQL的执行计划。格式如下：</p>\\n<div class=\\"language-text\\" data-ext=\\"text\\" data-title=\\"text\\"><pre class=\\"language-text\\"><code>{EXPLAIN | DESCRIBE | DESC}\\n    tbl_name [col_name | wild]\\n\\n{EXPLAIN | DESCRIBE | DESC}\\n    [explain_type]\\n    {explainable_stmt | FOR CONNECTION connection_id}\\n\\n{EXPLAIN | DESCRIBE | DESC} ANALYZE select_statement    \\n\\nexplain_type: {\\n    FORMAT = format_name\\n}\\n\\nformat_name: {\\n    TRADITIONAL\\n  | JSON\\n  | TREE\\n}\\n\\nexplainable_stmt: {\\n    SELECT statement\\n  | TABLE statement\\n  | DELETE statement\\n  | INSERT statement\\n  | REPLACE statement\\n  | UPDATE statement\\n}\\n</code></pre></div>","autoDesc":true}');export{m as comp,x as data};
