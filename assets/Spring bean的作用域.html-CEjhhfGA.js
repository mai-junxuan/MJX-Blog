import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,a as n,o as a}from"./app-BEFL3G1x.js";const o={};function d(c,e){return a(),i("div",null,[...e[0]||(e[0]=[n(`<h3 id="spring-bean的作用域" tabindex="-1"><a class="header-anchor" href="#spring-bean的作用域"><span>Spring bean的作用域</span></a></h3><p>阅读了一下<code>Spring</code>官方文档中，关于<code>bean</code>的作用域这一块的内容。<code>Spring5</code>官方文档中，共介绍了六种<code>bean</code>作用域，这篇文章来简单介绍一下这六种作用域的含义。</p><h4 id="_1-bean作用域的种类" tabindex="-1"><a class="header-anchor" href="#_1-bean作用域的种类"><span>1.Bean作用域的种类</span></a></h4><p>在<code>Spring</code>官方文档中，共提到了<code>6</code>种不同的<code>Bean</code>作用域，分别是：</p><p><img src="https://cdn.jsdelivr.net/gh/mai-junxuan/Cloud-image/image/202207151759375.png" alt="image-20220715175906301"></p><p>需要注意的是，前两种是<code>Spring</code>中<code>bean</code>的基本作用域，而后四种，算是扩展的作用域，只能在<code>web</code>应用中使用。下面我就来分别介绍一下这<code>6</code>种不同的作用域。</p><h5 id="_1-1-singleton作用域" tabindex="-1"><a class="header-anchor" href="#_1-1-singleton作用域"><span>1.1 singleton作用域</span></a></h5><p><strong>singleton（单例）是Spring中，bean默认的作用域</strong>。若一个<code>bean</code>的作用域是单例的，那么每个<code>IoC</code>容器只会创建这个<code>bean</code>的一个实例对象。所有对这个<code>bean</code>的依赖，以及获取这个<code>bean</code>的代码，拿到的都是同一个<code>bean</code>实例。<code>Spring</code>容器在创建这个<code>bean</code>后，会将它缓存在容器中（实际上是放在一个<code>ConcurrentHashMap</code>中）。<strong>Spring中的bean不是线程安全的，所以只有在我们只关注bean能够提供的功能，而不在意它的状态（属性）时，才应该使用这个作用域</strong>。</p><p>需要注意的一点是，这里所说的单例，和设计模式中所提到的单例模式不同。设计模式中的单例，是强制一个类有且只有一个对象，我们如果不通过特殊的手段，将无法为这个单例类创建多个对象。而<code>Spring</code>中的单例作用域不同，这里的单例指的是在一个<code>Spring</code>容器中，只会缓存<code>bean</code>的唯一对象，所有通过容器获取这个<code>bean</code>的方式，最终拿到的都是同一个对象。但是在不同的<code>Spring</code>容器中，每一个<code>Spring</code>容器都可以拥有单例<code>bean</code>的一个实例对象，也就是说，这里的单例限定在一个<code>Spring</code>容器中，而不是整个应用程序。并且我们依然可以通过<code>new</code>的方式去自己创建<code>bean</code>。</p><h5 id="_1-2-prototype作用域" tabindex="-1"><a class="header-anchor" href="#_1-2-prototype作用域"><span>1.2 prototype作用域</span></a></h5><p><code>prototype</code>可以理解为多例。若一个<code>bean</code>的作用域是<code>prototype</code>，那么<code>Spring</code>容器并不会缓存创建的<code>bean</code>，程序中对这个<code>bean</code>的每一次获取，容器都会重新实例化一个<code>bean</code>对象。<strong>通常，如果我们需要使用bean的状态（属性），且这个状态是会改变的，那么我们就可以将它配置为这个作用域，以解决线程安全的问题</strong>。因为对于单例<code>bean</code>来说，多个线程共享它的可变属性，会存在线程安全问题。</p><p>前面也提过，如果<code>bean</code>的作用域是<code>prototype</code>的，那么容器在创建完这个<code>bean</code>后，并不会将它保存在容器中，这也就意味着，<code>Spring</code>容器并不能为我们做这个对象的销毁工作（比如资源释放）。此时我们可以通过<code>Spring</code>提供的接口，自定义一个后处理器，然后将这些<code>bean</code>的引用存储在这个后处理器中，当容器回调这个后处理器的方法时，我们可以在方法中通过提前存储的<code>bean</code>的引用，将它们销毁。</p><h5 id="_1-3-request作用域" tabindex="-1"><a class="header-anchor" href="#_1-3-request作用域"><span>1.3 request作用域</span></a></h5><p><code>request</code>作用域将<code>bean</code>的使用范围限定在一个<code>http</code>请求中，对于每一个请求，都会单独创建一个<code>bean</code>，若请求结束，<code>bean</code>也会随之销毁。使用<code>request</code>作用域一般不会存在线程安全问题，因为在<code>Web</code>应用中，每个请求都是由一个单独的线程进行处理，所有线程之间并不会共享<code>bean</code>，从而不会存在线程安全的问题。</p><p>这个作用域只能使用在<code>Web</code>应用中。如果使用的是注解扫描配置<code>bean</code>，那么在<code>bean</code>所属的类上使用<code>@RequestScope</code>注解即可使用此作用域，若是基于<code>xml</code>文件，则通过<code>bean</code>的<code>scope</code>配置项：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>&lt;bean id=&quot;userPreferences&quot; class=&quot;com.foo.UserPreferences&quot; scope=&quot;request&quot;/&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h5 id="_1-4-session作用域" tabindex="-1"><a class="header-anchor" href="#_1-4-session作用域"><span>1.4 session作用域</span></a></h5><p><code>session</code>作用域将<code>bean</code>的使用范围一次在一次<code>http会话</code>中，对于每一个会话，<code>Spring</code>容器都会创建一个单独的<code>bean</code>，若<code>session</code>被销毁，则<code>bean</code>也随之销毁。我们可以修改<code>bean</code>的状态，这个修改只对当前会话可见，但是是否线程安全呢？<code>Spring</code>文档中并未提及，但我认为不是线程安全的，因为每一个<code>session</code>可以对应于多个<code>request</code>，这些请求不一定就是串行执行的，比如说用户打开多个界面，同时进行多次操作，那后台将同时处理同一个<code>session</code>的多个<code>request</code>，此时并不能保证<code>bean</code>的线程安全。</p><p>与<code>request</code>作用域一样，<code>session</code>作用域只能使用在<code>Web</code>应用中。我们可以使用<code>@SessionScope</code>将<code>bean</code>指定为<code>session</code>作用域，也可以使用<code>xml</code>配置方式：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>&lt;bean id=&quot;userPreferences&quot; class=&quot;com.foo.UserPreferences&quot; scope=&quot;session&quot;/&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h5 id="_1-5-application作用域" tabindex="-1"><a class="header-anchor" href="#_1-5-application作用域"><span>1.5 application作用域</span></a></h5><p>学过<code>Servlet</code>的应该对<code>application</code>作用域有所了解，在<code>Servlet</code>程序中，有一个全局的<code>ServletContext</code>对象，这个对象被整个<code>web</code>应用所共享，我们可以通过<code>setAttribute</code>方法向其中添加全局共享的数据。而<code>Spring</code>中，<code>application</code>作用域就是这么实现的，作用域为<code>application</code>的<code>bean</code>，将会被作为<code>ServletContext</code>的属性，存储在其中，然后可以被全局访问，而且一个<code>ServletContext</code>只会存储这个<code>bean</code>的一个实例对象。<code>ServletContext</code>被销毁，这个<code>bean</code>自然也跟着被销毁。我们发现，这好像有点类似于<code>singleton</code>这个作用域，确实非常类似，但是也有一些区别。单例<code>bean</code>是一个<code>Spring</code>只会创建一个，而这里的却是每个<code>ServletContext</code>包含一个，不论有多少<code>Spring</code>容器，<code>bean</code>的数量只取决于<code>ServletContext</code>，而且单例<code>bean</code>只能通过容器去获取，是隐式的，而这种作用域的<code>bean</code>却是公开的，存储在<code>ServletContext</code>中，可直接通过<code>ServletContext</code>获取。</p><p><code>application</code>作用域也只能用于<code>web</code>应用中。使用方式和之前几种类似，可以通过<code>@ApplicationScope</code>注解，也可以使用<code>xml</code>配置文件：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>&lt;bean id=&quot;appPreferences&quot; class=&quot;com.foo.AppPreferences&quot; scope=&quot;application&quot;/&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h5 id="_1-5-websocket作用域" tabindex="-1"><a class="header-anchor" href="#_1-5-websocket作用域"><span>1.5 websocket作用域</span></a></h5><p><code>websocket</code>是一种应用层的通信协议，它提供应用层的全双工通信，而<code>Spring</code>提供对<code>websocket</code>协议的支持，于是就有了这么一个作用域。在我看的这个<code>Spring</code>官方文档中。若一个<code>bean</code>的作用域为<code>websocket</code>，则只作用于一次<code>websocket</code>通信，若连接被释放，则<code>bean</code>自然也会被销毁。需要注意的一点是需要对 WebSocket 作用域的 Bean 使用作用域代理模式</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Component</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Scope</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">scopeName</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;websocket&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> proxyMode</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> ScopedProxyMode</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">TARGET_CLASS</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MyBean</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">PostConstruct</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> init</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // Invoked after dependencies injected</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // ...</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">PreDestroy</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> destroy</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // Invoked when the WebSocket session ends</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Controller</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MyController</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> final</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MyBean</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> myBean</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Autowired</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> MyController</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">MyBean</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> myBean</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">myBean</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> myBean;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">MessageMapping</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;/action&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> handle</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // this.myBean from the current WebSocket session</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2-为什么global-session没有了" tabindex="-1"><a class="header-anchor" href="#_2-为什么global-session没有了"><span>2. 为什么global session没有了？</span></a></h4><p>​ 在其他的文章中，我们常常可以看到会有global session这个作用域，但是为什么我们从刚刚的官方文档没有看到呢？</p><h5 id="global-session作用域是什么" tabindex="-1"><a class="header-anchor" href="#global-session作用域是什么"><span>global session作用域是什么</span></a></h5><p>这个作用域就比较特殊了，<code>globalSession</code>作用域的效果与<code>session</code>作用域类似，但是只适用于基于<code>portlet</code>的<code>web</code>应用程序中。<code>Portlet</code>规范定义了<code>globalSession</code>的概念，该概念在组成单个<code>Portlet Web</code>应用程序的所有<code>Portlet</code>之间共享（引用自<code>Spring</code>文档）。说实话，在看到这里之前，我从来没听说过<code>portlet</code>。我现在所学的，基本上都是基于<code>Servlet</code>的<code>web</code>应用程序，所有关于这个作用域，我也不理解。但是<code>Spring</code>文档中有提到一点，那就是<strong>如果我们在基于Servlet的web应用程序中使用globalSession作用域，实际上容器使用session作用域进行处理</strong>。</p><h5 id="spring5-去掉了global-session" tabindex="-1"><a class="header-anchor" href="#spring5-去掉了global-session"><span>spring5 去掉了global session</span></a></h5><p>​ 从StackOverFlow的一篇文章中找到了答案<a href="http://stackoverflow.com/questions/54742157/were-globalsession-scoped-beans-removed-from-spring-5-why" target="_blank" rel="noopener noreferrer">java - Were GlobalSession scoped beans removed from spring 5? Why? - Stack Overflow</a>，其中说到从Spring5开始停止了对Portlet的支持，从而去除掉了global session</p><p>​</p>`,34)])])}const p=s(o,[["render",d]]),r=JSON.parse('{"path":"/%E6%A1%86%E6%9E%B6/Spring/Spring%20bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F.html","title":"","lang":"zh-CN","frontmatter":{"description":"Spring bean的作用域 阅读了一下Spring官方文档中，关于bean的作用域这一块的内容。Spring5官方文档中，共介绍了六种bean作用域，这篇文章来简单介绍一下这六种作用域的含义。 1.Bean作用域的种类 在Spring官方文档中，共提到了6种不同的Bean作用域，分别是： image-20220715175906301 需要注意的是...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"https://cdn.jsdelivr.net/gh/mai-junxuan/Cloud-image/image/202207151759375.png\\"],\\"dateModified\\":\\"2023-06-13T21:01:35.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"maijunxuan\\",\\"email\\":\\"maijunxuan0309@gmail.com\\"}]}"],["meta",{"property":"og:url","content":"https://maijunxuan.cn/%E6%A1%86%E6%9E%B6/Spring/Spring%20bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F.html"}],["meta",{"property":"og:site_name","content":"麦俊轩的博客"}],["meta",{"property":"og:description","content":"Spring bean的作用域 阅读了一下Spring官方文档中，关于bean的作用域这一块的内容。Spring5官方文档中，共介绍了六种bean作用域，这篇文章来简单介绍一下这六种作用域的含义。 1.Bean作用域的种类 在Spring官方文档中，共提到了6种不同的Bean作用域，分别是： image-20220715175906301 需要注意的是..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.jsdelivr.net/gh/mai-junxuan/Cloud-image/image/202207151759375.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-06-13T21:01:35.000Z"}],["meta",{"property":"article:modified_time","content":"2023-06-13T21:01:35.000Z"}]]},"git":{"createdTime":1663601526000,"updatedTime":1686690095000,"contributors":[{"name":"MJX","username":"MJX","email":"1585225345@qq.com","commits":3,"url":"https://github.com/MJX"}]},"readingTime":{"minutes":6.92,"words":2075},"filePathRelative":"框架/Spring/Spring bean的作用域.md","excerpt":"<h3>Spring bean的作用域</h3>\\n<p>阅读了一下<code>Spring</code>官方文档中，关于<code>bean</code>的作用域这一块的内容。<code>Spring5</code>官方文档中，共介绍了六种<code>bean</code>作用域，这篇文章来简单介绍一下这六种作用域的含义。</p>\\n<h4>1.Bean作用域的种类</h4>\\n<p>在<code>Spring</code>官方文档中，共提到了<code>6</code>种不同的<code>Bean</code>作用域，分别是：</p>\\n<p><img src=\\"https://cdn.jsdelivr.net/gh/mai-junxuan/Cloud-image/image/202207151759375.png\\" alt=\\"image-20220715175906301\\"></p>","autoDesc":true}');export{p as comp,r as data};
