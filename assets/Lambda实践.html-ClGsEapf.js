import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as a,c as n,a as t}from"./app-BJyX0H20.js";const i={},l=t(`<h1 id="lambda实践" tabindex="-1"><a class="header-anchor" href="#lambda实践"><span>Lambda实践</span></a></h1><h2 id="java8以前的comparator和java8的comparator" tabindex="-1"><a class="header-anchor" href="#java8以前的comparator和java8的comparator"><span>java8以前的comparator和java8的comparator</span></a></h2><p>可以看到使用lambda表达式，使得对象的创建以及声明变得简单且优雅</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>//老版本的比较器声明方式
Comparator&lt;Apple&gt; comparator=new Comparator&lt;Apple&gt;() {
    @Override
    public int compare(Apple a1, Apple a2) {
        return a1.getWeight().compareTo(a2.getWeight());
    }
};
//java8的比较器的声明方式
Comparator&lt;Apple&gt; cmp=(a1,a2)-&gt;a1.getWeight().compareTo(a2.getWeight());
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="lambda的优势" tabindex="-1"><a class="header-anchor" href="#lambda的优势"><span>lambda的优势</span></a></h2><ol><li>匿名：使用lambda声明方法无需像普通方法需要很多明确的东西，它给了我们一种写得少但是想得多的优雅</li><li>函数：lambda表达式用起来就和方法一样，有参数列表、函数主体、返回值等</li><li>传递：lambda可以作为参数传递或者存储在变量中</li><li>简洁：如上文所示的代码，使用lambda可以避免没必要的模板编写，优雅且简洁</li></ol><h2 id="lambda的使用场景" tabindex="-1"><a class="header-anchor" href="#lambda的使用场景"><span>lambda的使用场景</span></a></h2><h3 id="函数式接口" tabindex="-1"><a class="header-anchor" href="#函数式接口"><span>函数式接口</span></a></h3><p>在介绍lambda表达式之前我们需要先介绍一下函数式接口，因为lambda就是为缩写函数式的接口而生的。 如下图所示Runnable接口就是一个函数式接口，函数式接口的特征也很明显，他是一个接口，且有且只有一个方法。并且还有一个注解<code>@FunctionalInterface</code>,需要说明的是这个注解非必须的，他只是告知编译器这是个函数式接口而已，让编译器留点心 也正是因为方法为一，才能确保简洁的lambda表达式可以唯一确定匹配接口的方法。</p><p><img src="https://cdn.jsdelivr.net/gh/mai-junxuan/Cloud-image/image/202209052232783.png" alt="image-20220905223204749"></p><h3 id="函数式描述符" tabindex="-1"><a class="header-anchor" href="#函数式描述符"><span>函数式描述符</span></a></h3><p>了解了函数式接口，了解函数描述符就很简单了，以Runnable为例，他的方法是 <code>public abstract void run();</code> 所以他是一个没有参数且没有返回值的方法。 那么它的函数描述符就是<code>() -&gt; void</code>，后续我们使用lambda表达式的时候只要遵循这个表达式即可。 再看看一个例子，这也是笔者自定义的一个函数式接口，可以看出他的入参是一个苹果类，返回值是boolean，所以它的函数描述符是**(Apple)-&gt;boolean**</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>interface ApplePredicate{
         boolean test(Apple a);
    }
ApplePredicate applePredicate=(a)-&gt;true;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这就是为什么我们声明ApplePredicate可以缩写成下文所示</p><h2 id="使用lambda优化环绕执行模式的调用" tabindex="-1"><a class="header-anchor" href="#使用lambda优化环绕执行模式的调用"><span>使用lambda优化环绕执行模式的调用</span></a></h2><h3 id="需求描述" tabindex="-1"><a class="header-anchor" href="#需求描述"><span>需求描述</span></a></h3><p>我们现在有个文件data.txt,它的内容为</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>Java
8
Lambdas
In
Action
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们希望编写的代码只读取第1行的结果然后返回即可</p><h3 id="代码实现" tabindex="-1"><a class="header-anchor" href="#代码实现"><span>代码实现</span></a></h3><p>可以看到这个需求实现也非常简单，如下所示</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code> public static String processFileLimited() throws IOException {
        try (BufferedReader br =
                     new BufferedReader(new FileReader(&quot;F:\\\\github\\\\src\\\\main\\\\resources\\\\lambdasinaction\\\\chap3\\\\data.txt&quot;))) {
            return br.readLine();
        }
    }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="项目演进" tabindex="-1"><a class="header-anchor" href="#项目演进"><span>项目演进</span></a></h3><h4 id="需求描述-1" tabindex="-1"><a class="header-anchor" href="#需求描述-1"><span>需求描述</span></a></h4><p>现在需求变了，我们希望能够读取两行，后续可能还会发生变化，这时候警觉的你就会发现读取文件这个行为可能多变无常，我们需要对变化进行封装</p><h4 id="声明函数式接口" tabindex="-1"><a class="header-anchor" href="#声明函数式接口"><span>声明函数式接口</span></a></h4><p>所以我们将读取文件这个行为封装成一个函数式接口，代码如下所示</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>public interface BufferedReaderProcessor{
         String process(BufferedReader b) throws IOException;

    }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="修改原有方法逻辑" tabindex="-1"><a class="header-anchor" href="#修改原有方法逻辑"><span>修改原有方法逻辑</span></a></h4><p>这时候我们在进行行为参数化，将读取文件内容这个逻辑参数化，后续我们就可以大展身手了</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>public static String processFile(BufferedReaderProcessor p) throws IOException {
        try(BufferedReader br = new BufferedReader(new FileReader(&quot;F:\\\\github\\\\Java8InAction\\\\src\\\\main\\\\resources\\\\lambdasinaction\\\\chap3\\\\data.txt&quot;))){
            return p.process(br);
        }
    }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="调用并查看测试结果" tabindex="-1"><a class="header-anchor" href="#调用并查看测试结果"><span>调用并查看测试结果</span></a></h4><p>这时候我们就可以使用lambda进行调用测试了</p><p>测试读取1行</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>//        测试读取1行 输出结果 Java
        String s = processFile(b -&gt; b.readLine());
        System.out.println(s);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试读取2行</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>//        测试读取2行 输出结果 Java 8
        String s2 = processFile(b -&gt; b.readLine()+&quot; &quot;+b.readLine());
        System.out.println(s2);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试读取1行并行尾加上 &quot;本人已读&quot;</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>        //测试读取1行并行尾加上 &quot;本人已读&quot; 输出结果 Java 本人已读
        String s3 = processFile(b -&gt; b.readLine()+&quot; 本人已读&quot;);
        System.out.println(s3);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="现成的轮子-java8自带的函数式接口" tabindex="-1"><a class="header-anchor" href="#现成的轮子-java8自带的函数式接口"><span>&quot;现成的轮子&quot; java8自带的函数式接口</span></a></h2><h3 id="简介" tabindex="-1"><a class="header-anchor" href="#简介"><span>简介</span></a></h3><p>其实面对常见的行为参数化，java已经考虑到这些情况了，他也为我们提供了不少的现有轮子，下面我们就来一一介绍几个常见的轮子</p><h3 id="predicate" tabindex="-1"><a class="header-anchor" href="#predicate"><span>Predicate</span></a></h3><p>这个接口就是针对于那些需要传入指定类型，并返回Boolean行的行为，例如：我们需要一组对字符串进行判断操作的行为，我们可以先这样写一个方法，通过Predicate将行为参数化</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>public static boolean test(String s,Predicate&lt;String&gt; p){
        return p.test(s);
    }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>假如我们需要判断字符串是大于2，我们就可以这样调用</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code> boolean result = test(&quot;123&quot;, (s) -&gt; s.length() &gt; 12);
        System.out.println(result);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>假如我们需要判断字符串是否为test，我们可以这样调用</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>  boolean result=test(&quot;test&quot;,(s)-&gt;&quot;test&quot;.equals(s));
        System.out.println(result);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="consumer" tabindex="-1"><a class="header-anchor" href="#consumer"><span>Consumer</span></a></h3><p>与上同理，Consumer的函数描述符为<code>(T)-&gt;void</code>,即传入任意类型，无返回值的操作。 例如我们现在要遍历并输出不同类型的元素，我们可以先定义一个方法，将consumer行为参数化</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code> public static &lt;T&gt; void   forEach(List&lt;T&gt; list, Consumer&lt;T&gt; consumer){
        for (T t : list) {
            consumer.accept(t);
        }
    } 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>假如我们要遍历整形数组，我们可以这样</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code> List&lt;Integer&gt; integerList=new ArrayList&lt;&gt;();
        integerList.add(1);
        integerList.add(2);
        integerList.add(3);
        integerList.add(4);
        forEach(integerList,(i)-&gt; System.out.println(i));
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="function" tabindex="-1"><a class="header-anchor" href="#function"><span>Function</span></a></h3><p>通过查看源码，function的定义如下，不难看出，它适用于那些传入T类型返回R类型的行为</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>@FunctionalInterface
public interface Function&lt;T, R&gt; {
    R apply(T t);

}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>假如我们要求传入一个字符串，返回它的长度或者字符串第1位unocode码值，我们就可以使用Function做到。 首先我们定义一个方法，将返回整型的行为参数化，如下所示</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code> public static Integer StringCalculate(String s, Function&lt;String,Integer&gt; function){
        return function.apply(s);
    }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>调用如下所示</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>        //获取字符串长度
        System.out.println(StringCalculate(&quot;123&quot;, (s) -&gt; s.length()));
//        获取字符串第1位unicode
        System.out.println(StringCalculate(&quot;132&quot;, (s) -&gt; s.codePointAt(0)));
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="更多函数式接口" tabindex="-1"><a class="header-anchor" href="#更多函数式接口"><span>更多函数式接口</span></a></h3><p><img src="https://cdn.jsdelivr.net/gh/mai-junxuan/Cloud-image/image/202209052231413.png" alt="image-20220905223123171"> ![在这</p><h2 id="lambda工作原理简析" tabindex="-1"><a class="header-anchor" href="#lambda工作原理简析"><span>lambda工作原理简析</span></a></h2><h3 id="类型检查" tabindex="-1"><a class="header-anchor" href="#类型检查"><span>类型检查</span></a></h3><p>那么问题来了，lambda表达式如此精简，请问它是如何完成类型检查的呢？我们就以下面代码为例，可以看到这段代码就是根据传入的String返回相应的boolean值</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>public static &lt;T&gt; boolean test(T s, Predicate&lt;T&gt; p) {
        return p.test(s);
    }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>假如我们这样调用</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>boolean result = test(&quot;123&quot;, (String s) -&gt; s.length() &gt; 12);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>他的匹配过程就如下图所示，首先根据调用方法找到主方法，根据主方法的泛型得知入参是String，再查看predicate的唯一方法得知返回值是boolean，由此得知函数描述符为<code>String-&gt;boolean</code>,最终和调用的lambda匹配成功，校验通过</p><p><img src="https://cdn.jsdelivr.net/gh/mai-junxuan/Cloud-image/image/202209052228365.png" alt="image-20220905222806554"></p><h3 id="类型推断" tabindex="-1"><a class="header-anchor" href="#类型推断"><span>类型推断</span></a></h3><p>因为函数式接口方法是唯一的，我们也可以对类型进行省略，让java编译器去自动推断类型</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code> boolean result = test(&quot;123&quot;, (s) -&gt; s.length() &gt; 12);
        System.out.println(result);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="使用限制-使用lambda使用局部变量" tabindex="-1"><a class="header-anchor" href="#使用限制-使用lambda使用局部变量"><span>使用限制(使用lambda使用局部变量)</span></a></h3><p>如下代码所示，这样一段代码在idea中会报红，原因很简单，局部变量分配在栈上，而r线程可能会在该变量被回收之后才使用这个变量，所以java在让线程r访问这个变量的时候，实际上访问到的num是num的副本，所以假如lambda访问变量num，再给num赋值就会爆红，因为如下所示代码若能正常执行，那么r线程最终输出的num很可能前后不一致是随机，进而导致线程安全问题。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code> <span class="token keyword">int</span> num<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
 <span class="token class-name">Runnable</span> r<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
 r<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 num<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,77),s=[l];function d(r,c){return a(),n("div",null,s)}const p=e(i,[["render",d],["__file","Lambda实践.html.vue"]]),m=JSON.parse('{"path":"/Java/Lambda%E5%AE%9E%E8%B7%B5.html","title":"Lambda实践","lang":"zh-CN","frontmatter":{"description":"Lambda实践 java8以前的comparator和java8的comparator 可以看到使用lambda表达式，使得对象的创建以及声明变得简单且优雅 lambda的优势 匿名：使用lambda声明方法无需像普通方法需要很多明确的东西，它给了我们一种写得少但是想得多的优雅 函数：lambda表达式用起来就和方法一样，有参数列表、函数主体、返回值...","head":[["meta",{"property":"og:url","content":"https://maijunxuan.cn/Java/Lambda%E5%AE%9E%E8%B7%B5.html"}],["meta",{"property":"og:site_name","content":"麦俊轩的博客"}],["meta",{"property":"og:title","content":"Lambda实践"}],["meta",{"property":"og:description","content":"Lambda实践 java8以前的comparator和java8的comparator 可以看到使用lambda表达式，使得对象的创建以及声明变得简单且优雅 lambda的优势 匿名：使用lambda声明方法无需像普通方法需要很多明确的东西，它给了我们一种写得少但是想得多的优雅 函数：lambda表达式用起来就和方法一样，有参数列表、函数主体、返回值..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.jsdelivr.net/gh/mai-junxuan/Cloud-image/image/202209052232783.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-06-13T21:01:35.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"Lambda实践"}],["meta",{"property":"article:author","content":"maijunxuan"}],["meta",{"property":"article:modified_time","content":"2023-06-13T21:01:35.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Lambda实践\\",\\"image\\":[\\"https://cdn.jsdelivr.net/gh/mai-junxuan/Cloud-image/image/202209052232783.png\\",\\"https://cdn.jsdelivr.net/gh/mai-junxuan/Cloud-image/image/202209052231413.png\\",\\"https://cdn.jsdelivr.net/gh/mai-junxuan/Cloud-image/image/202209052228365.png\\"],\\"dateModified\\":\\"2023-06-13T21:01:35.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"maijunxuan\\",\\"email\\":\\"maijunxuan0309@gmail.com\\"}]}"]]},"headers":[{"level":2,"title":"java8以前的comparator和java8的comparator","slug":"java8以前的comparator和java8的comparator","link":"#java8以前的comparator和java8的comparator","children":[]},{"level":2,"title":"lambda的优势","slug":"lambda的优势","link":"#lambda的优势","children":[]},{"level":2,"title":"lambda的使用场景","slug":"lambda的使用场景","link":"#lambda的使用场景","children":[{"level":3,"title":"函数式接口","slug":"函数式接口","link":"#函数式接口","children":[]},{"level":3,"title":"函数式描述符","slug":"函数式描述符","link":"#函数式描述符","children":[]}]},{"level":2,"title":"使用lambda优化环绕执行模式的调用","slug":"使用lambda优化环绕执行模式的调用","link":"#使用lambda优化环绕执行模式的调用","children":[{"level":3,"title":"需求描述","slug":"需求描述","link":"#需求描述","children":[]},{"level":3,"title":"代码实现","slug":"代码实现","link":"#代码实现","children":[]},{"level":3,"title":"项目演进","slug":"项目演进","link":"#项目演进","children":[]}]},{"level":2,"title":"\\"现成的轮子\\" java8自带的函数式接口","slug":"现成的轮子-java8自带的函数式接口","link":"#现成的轮子-java8自带的函数式接口","children":[{"level":3,"title":"简介","slug":"简介","link":"#简介","children":[]},{"level":3,"title":"Predicate","slug":"predicate","link":"#predicate","children":[]},{"level":3,"title":"Consumer","slug":"consumer","link":"#consumer","children":[]},{"level":3,"title":"Function","slug":"function","link":"#function","children":[]},{"level":3,"title":"更多函数式接口","slug":"更多函数式接口","link":"#更多函数式接口","children":[]}]},{"level":2,"title":"lambda工作原理简析","slug":"lambda工作原理简析","link":"#lambda工作原理简析","children":[{"level":3,"title":"类型检查","slug":"类型检查","link":"#类型检查","children":[]},{"level":3,"title":"类型推断","slug":"类型推断","link":"#类型推断","children":[]},{"level":3,"title":"使用限制(使用lambda使用局部变量)","slug":"使用限制-使用lambda使用局部变量","link":"#使用限制-使用lambda使用局部变量","children":[]}]}],"git":{"createdTime":1662395905000,"updatedTime":1686690095000,"contributors":[{"name":"MJX","email":"1585225345@qq.com","commits":3}]},"readingTime":{"minutes":6.42,"words":1926},"filePathRelative":"Java/Lambda实践.md","localizedDate":"2022年9月5日","excerpt":"\\n<h2>java8以前的comparator和java8的comparator</h2>\\n<p>可以看到使用lambda表达式，使得对象的创建以及声明变得简单且优雅</p>\\n<div class=\\"language-text\\" data-ext=\\"text\\" data-title=\\"text\\"><pre class=\\"language-text\\"><code>//老版本的比较器声明方式\\nComparator&lt;Apple&gt; comparator=new Comparator&lt;Apple&gt;() {\\n    @Override\\n    public int compare(Apple a1, Apple a2) {\\n        return a1.getWeight().compareTo(a2.getWeight());\\n    }\\n};\\n//java8的比较器的声明方式\\nComparator&lt;Apple&gt; cmp=(a1,a2)-&gt;a1.getWeight().compareTo(a2.getWeight());\\n</code></pre></div>","autoDesc":true}');export{p as comp,m as data};
