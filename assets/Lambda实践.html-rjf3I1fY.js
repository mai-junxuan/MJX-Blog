import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,a as e,o as n}from"./app-DDXXRmhs.js";const l={};function t(d,a){return n(),i("div",null,[...a[0]||(a[0]=[e(`<h1 id="lambda实践" tabindex="-1"><a class="header-anchor" href="#lambda实践"><span>Lambda实践</span></a></h1><h2 id="java8以前的comparator和java8的comparator" tabindex="-1"><a class="header-anchor" href="#java8以前的comparator和java8的comparator"><span>java8以前的comparator和java8的comparator</span></a></h2><p>可以看到使用lambda表达式，使得对象的创建以及声明变得简单且优雅</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>//老版本的比较器声明方式</span></span>
<span class="line"><span>Comparator&lt;Apple&gt; comparator=new Comparator&lt;Apple&gt;() {</span></span>
<span class="line"><span>    @Override</span></span>
<span class="line"><span>    public int compare(Apple a1, Apple a2) {</span></span>
<span class="line"><span>        return a1.getWeight().compareTo(a2.getWeight());</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span>//java8的比较器的声明方式</span></span>
<span class="line"><span>Comparator&lt;Apple&gt; cmp=(a1,a2)-&gt;a1.getWeight().compareTo(a2.getWeight());</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="lambda的优势" tabindex="-1"><a class="header-anchor" href="#lambda的优势"><span>lambda的优势</span></a></h2><ol><li>匿名：使用lambda声明方法无需像普通方法需要很多明确的东西，它给了我们一种写得少但是想得多的优雅</li><li>函数：lambda表达式用起来就和方法一样，有参数列表、函数主体、返回值等</li><li>传递：lambda可以作为参数传递或者存储在变量中</li><li>简洁：如上文所示的代码，使用lambda可以避免没必要的模板编写，优雅且简洁</li></ol><h2 id="lambda的使用场景" tabindex="-1"><a class="header-anchor" href="#lambda的使用场景"><span>lambda的使用场景</span></a></h2><h3 id="函数式接口" tabindex="-1"><a class="header-anchor" href="#函数式接口"><span>函数式接口</span></a></h3><p>在介绍lambda表达式之前我们需要先介绍一下函数式接口，因为lambda就是为缩写函数式的接口而生的。 如下图所示Runnable接口就是一个函数式接口，函数式接口的特征也很明显，他是一个接口，且有且只有一个方法。并且还有一个注解<code>@FunctionalInterface</code>,需要说明的是这个注解非必须的，他只是告知编译器这是个函数式接口而已，让编译器留点心 也正是因为方法为一，才能确保简洁的lambda表达式可以唯一确定匹配接口的方法。</p><p><img src="https://cdn.jsdelivr.net/gh/mai-junxuan/Cloud-image/image/202209052232783.png" alt="image-20220905223204749"></p><h3 id="函数式描述符" tabindex="-1"><a class="header-anchor" href="#函数式描述符"><span>函数式描述符</span></a></h3><p>了解了函数式接口，了解函数描述符就很简单了，以Runnable为例，他的方法是 <code>public abstract void run();</code> 所以他是一个没有参数且没有返回值的方法。 那么它的函数描述符就是<code>() -&gt; void</code>，后续我们使用lambda表达式的时候只要遵循这个表达式即可。 再看看一个例子，这也是笔者自定义的一个函数式接口，可以看出他的入参是一个苹果类，返回值是boolean，所以它的函数描述符是**(Apple)-&gt;boolean**</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>interface ApplePredicate{</span></span>
<span class="line"><span>         boolean test(Apple a);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>ApplePredicate applePredicate=(a)-&gt;true;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这就是为什么我们声明ApplePredicate可以缩写成下文所示</p><h2 id="使用lambda优化环绕执行模式的调用" tabindex="-1"><a class="header-anchor" href="#使用lambda优化环绕执行模式的调用"><span>使用lambda优化环绕执行模式的调用</span></a></h2><h3 id="需求描述" tabindex="-1"><a class="header-anchor" href="#需求描述"><span>需求描述</span></a></h3><p>我们现在有个文件data.txt,它的内容为</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>Java</span></span>
<span class="line"><span>8</span></span>
<span class="line"><span>Lambdas</span></span>
<span class="line"><span>In</span></span>
<span class="line"><span>Action</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们希望编写的代码只读取第1行的结果然后返回即可</p><h3 id="代码实现" tabindex="-1"><a class="header-anchor" href="#代码实现"><span>代码实现</span></a></h3><p>可以看到这个需求实现也非常简单，如下所示</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span> public static String processFileLimited() throws IOException {</span></span>
<span class="line"><span>        try (BufferedReader br =</span></span>
<span class="line"><span>                     new BufferedReader(new FileReader(&quot;F:\\\\github\\\\src\\\\main\\\\resources\\\\lambdasinaction\\\\chap3\\\\data.txt&quot;))) {</span></span>
<span class="line"><span>            return br.readLine();</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="项目演进" tabindex="-1"><a class="header-anchor" href="#项目演进"><span>项目演进</span></a></h3><h4 id="需求描述-1" tabindex="-1"><a class="header-anchor" href="#需求描述-1"><span>需求描述</span></a></h4><p>现在需求变了，我们希望能够读取两行，后续可能还会发生变化，这时候警觉的你就会发现读取文件这个行为可能多变无常，我们需要对变化进行封装</p><h4 id="声明函数式接口" tabindex="-1"><a class="header-anchor" href="#声明函数式接口"><span>声明函数式接口</span></a></h4><p>所以我们将读取文件这个行为封装成一个函数式接口，代码如下所示</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>public interface BufferedReaderProcessor{</span></span>
<span class="line"><span>         String process(BufferedReader b) throws IOException;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="修改原有方法逻辑" tabindex="-1"><a class="header-anchor" href="#修改原有方法逻辑"><span>修改原有方法逻辑</span></a></h4><p>这时候我们在进行行为参数化，将读取文件内容这个逻辑参数化，后续我们就可以大展身手了</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>public static String processFile(BufferedReaderProcessor p) throws IOException {</span></span>
<span class="line"><span>        try(BufferedReader br = new BufferedReader(new FileReader(&quot;F:\\\\github\\\\Java8InAction\\\\src\\\\main\\\\resources\\\\lambdasinaction\\\\chap3\\\\data.txt&quot;))){</span></span>
<span class="line"><span>            return p.process(br);</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="调用并查看测试结果" tabindex="-1"><a class="header-anchor" href="#调用并查看测试结果"><span>调用并查看测试结果</span></a></h4><p>这时候我们就可以使用lambda进行调用测试了</p><p>测试读取1行</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>//        测试读取1行 输出结果 Java</span></span>
<span class="line"><span>        String s = processFile(b -&gt; b.readLine());</span></span>
<span class="line"><span>        System.out.println(s);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试读取2行</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>//        测试读取2行 输出结果 Java 8</span></span>
<span class="line"><span>        String s2 = processFile(b -&gt; b.readLine()+&quot; &quot;+b.readLine());</span></span>
<span class="line"><span>        System.out.println(s2);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试读取1行并行尾加上 &quot;本人已读&quot;</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>        //测试读取1行并行尾加上 &quot;本人已读&quot; 输出结果 Java 本人已读</span></span>
<span class="line"><span>        String s3 = processFile(b -&gt; b.readLine()+&quot; 本人已读&quot;);</span></span>
<span class="line"><span>        System.out.println(s3);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="现成的轮子-java8自带的函数式接口" tabindex="-1"><a class="header-anchor" href="#现成的轮子-java8自带的函数式接口"><span>&quot;现成的轮子&quot; java8自带的函数式接口</span></a></h2><h3 id="简介" tabindex="-1"><a class="header-anchor" href="#简介"><span>简介</span></a></h3><p>其实面对常见的行为参数化，java已经考虑到这些情况了，他也为我们提供了不少的现有轮子，下面我们就来一一介绍几个常见的轮子</p><h3 id="predicate" tabindex="-1"><a class="header-anchor" href="#predicate"><span>Predicate</span></a></h3><p>这个接口就是针对于那些需要传入指定类型，并返回Boolean行的行为，例如：我们需要一组对字符串进行判断操作的行为，我们可以先这样写一个方法，通过Predicate将行为参数化</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>public static boolean test(String s,Predicate&lt;String&gt; p){</span></span>
<span class="line"><span>        return p.test(s);</span></span>
<span class="line"><span>    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>假如我们需要判断字符串是大于2，我们就可以这样调用</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span> boolean result = test(&quot;123&quot;, (s) -&gt; s.length() &gt; 12);</span></span>
<span class="line"><span>        System.out.println(result);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>假如我们需要判断字符串是否为test，我们可以这样调用</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>  boolean result=test(&quot;test&quot;,(s)-&gt;&quot;test&quot;.equals(s));</span></span>
<span class="line"><span>        System.out.println(result);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="consumer" tabindex="-1"><a class="header-anchor" href="#consumer"><span>Consumer</span></a></h3><p>与上同理，Consumer的函数描述符为<code>(T)-&gt;void</code>,即传入任意类型，无返回值的操作。 例如我们现在要遍历并输出不同类型的元素，我们可以先定义一个方法，将consumer行为参数化</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span> public static &lt;T&gt; void   forEach(List&lt;T&gt; list, Consumer&lt;T&gt; consumer){</span></span>
<span class="line"><span>        for (T t : list) {</span></span>
<span class="line"><span>            consumer.accept(t);</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>假如我们要遍历整形数组，我们可以这样</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span> List&lt;Integer&gt; integerList=new ArrayList&lt;&gt;();</span></span>
<span class="line"><span>        integerList.add(1);</span></span>
<span class="line"><span>        integerList.add(2);</span></span>
<span class="line"><span>        integerList.add(3);</span></span>
<span class="line"><span>        integerList.add(4);</span></span>
<span class="line"><span>        forEach(integerList,(i)-&gt; System.out.println(i));</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="function" tabindex="-1"><a class="header-anchor" href="#function"><span>Function</span></a></h3><p>通过查看源码，function的定义如下，不难看出，它适用于那些传入T类型返回R类型的行为</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>@FunctionalInterface</span></span>
<span class="line"><span>public interface Function&lt;T, R&gt; {</span></span>
<span class="line"><span>    R apply(T t);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>假如我们要求传入一个字符串，返回它的长度或者字符串第1位unocode码值，我们就可以使用Function做到。 首先我们定义一个方法，将返回整型的行为参数化，如下所示</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span> public static Integer StringCalculate(String s, Function&lt;String,Integer&gt; function){</span></span>
<span class="line"><span>        return function.apply(s);</span></span>
<span class="line"><span>    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>调用如下所示</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>        //获取字符串长度</span></span>
<span class="line"><span>        System.out.println(StringCalculate(&quot;123&quot;, (s) -&gt; s.length()));</span></span>
<span class="line"><span>//        获取字符串第1位unicode</span></span>
<span class="line"><span>        System.out.println(StringCalculate(&quot;132&quot;, (s) -&gt; s.codePointAt(0)));</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="更多函数式接口" tabindex="-1"><a class="header-anchor" href="#更多函数式接口"><span>更多函数式接口</span></a></h3><p><img src="https://cdn.jsdelivr.net/gh/mai-junxuan/Cloud-image/image/202209052231413.png" alt="image-20220905223123171"> ![在这</p><h2 id="lambda工作原理简析" tabindex="-1"><a class="header-anchor" href="#lambda工作原理简析"><span>lambda工作原理简析</span></a></h2><h3 id="类型检查" tabindex="-1"><a class="header-anchor" href="#类型检查"><span>类型检查</span></a></h3><p>那么问题来了，lambda表达式如此精简，请问它是如何完成类型检查的呢？我们就以下面代码为例，可以看到这段代码就是根据传入的String返回相应的boolean值</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>public static &lt;T&gt; boolean test(T s, Predicate&lt;T&gt; p) {</span></span>
<span class="line"><span>        return p.test(s);</span></span>
<span class="line"><span>    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>假如我们这样调用</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>boolean result = test(&quot;123&quot;, (String s) -&gt; s.length() &gt; 12);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>他的匹配过程就如下图所示，首先根据调用方法找到主方法，根据主方法的泛型得知入参是String，再查看predicate的唯一方法得知返回值是boolean，由此得知函数描述符为<code>String-&gt;boolean</code>,最终和调用的lambda匹配成功，校验通过</p><p><img src="https://cdn.jsdelivr.net/gh/mai-junxuan/Cloud-image/image/202209052228365.png" alt="image-20220905222806554"></p><h3 id="类型推断" tabindex="-1"><a class="header-anchor" href="#类型推断"><span>类型推断</span></a></h3><p>因为函数式接口方法是唯一的，我们也可以对类型进行省略，让java编译器去自动推断类型</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span> boolean result = test(&quot;123&quot;, (s) -&gt; s.length() &gt; 12);</span></span>
<span class="line"><span>        System.out.println(result);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="使用限制-使用lambda使用局部变量" tabindex="-1"><a class="header-anchor" href="#使用限制-使用lambda使用局部变量"><span>使用限制(使用lambda使用局部变量)</span></a></h3><p>如下代码所示，这样一段代码在idea中会报红，原因很简单，局部变量分配在栈上，而r线程可能会在该变量被回收之后才使用这个变量，所以java在让线程r访问这个变量的时候，实际上访问到的num是num的副本，所以假如lambda访问变量num，再给num赋值就会爆红，因为如下所示代码若能正常执行，那么r线程最终输出的num很可能前后不一致是随机，进而导致线程安全问题。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> num</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Runnable</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> r</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(num);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> r</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">run</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> num</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,77)])])}const c=s(l,[["render",t]]),h=JSON.parse('{"path":"/Java/Lambda%E5%AE%9E%E8%B7%B5.html","title":"Lambda实践","lang":"zh-CN","frontmatter":{"description":"Lambda实践 java8以前的comparator和java8的comparator 可以看到使用lambda表达式，使得对象的创建以及声明变得简单且优雅 lambda的优势 匿名：使用lambda声明方法无需像普通方法需要很多明确的东西，它给了我们一种写得少但是想得多的优雅 函数：lambda表达式用起来就和方法一样，有参数列表、函数主体、返回值...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Lambda实践\\",\\"image\\":[\\"https://cdn.jsdelivr.net/gh/mai-junxuan/Cloud-image/image/202209052232783.png\\",\\"https://cdn.jsdelivr.net/gh/mai-junxuan/Cloud-image/image/202209052231413.png\\",\\"https://cdn.jsdelivr.net/gh/mai-junxuan/Cloud-image/image/202209052228365.png\\"],\\"dateModified\\":\\"2023-06-13T21:01:35.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"maijunxuan\\",\\"email\\":\\"maijunxuan0309@gmail.com\\"}]}"],["meta",{"property":"og:url","content":"https://maijunxuan.cn/Java/Lambda%E5%AE%9E%E8%B7%B5.html"}],["meta",{"property":"og:site_name","content":"麦俊轩的博客"}],["meta",{"property":"og:title","content":"Lambda实践"}],["meta",{"property":"og:description","content":"Lambda实践 java8以前的comparator和java8的comparator 可以看到使用lambda表达式，使得对象的创建以及声明变得简单且优雅 lambda的优势 匿名：使用lambda声明方法无需像普通方法需要很多明确的东西，它给了我们一种写得少但是想得多的优雅 函数：lambda表达式用起来就和方法一样，有参数列表、函数主体、返回值..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.jsdelivr.net/gh/mai-junxuan/Cloud-image/image/202209052232783.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-06-13T21:01:35.000Z"}],["meta",{"property":"article:modified_time","content":"2023-06-13T21:01:35.000Z"}]]},"git":{"createdTime":1662395905000,"updatedTime":1686690095000,"contributors":[{"name":"MJX","username":"MJX","email":"1585225345@qq.com","commits":3,"url":"https://github.com/MJX"}]},"readingTime":{"minutes":6.42,"words":1926},"filePathRelative":"Java/Lambda实践.md","excerpt":"\\n<h2>java8以前的comparator和java8的comparator</h2>\\n<p>可以看到使用lambda表达式，使得对象的创建以及声明变得简单且优雅</p>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code class=\\"language-\\"><span class=\\"line\\"><span>//老版本的比较器声明方式</span></span>\\n<span class=\\"line\\"><span>Comparator&lt;Apple&gt; comparator=new Comparator&lt;Apple&gt;() {</span></span>\\n<span class=\\"line\\"><span>    @Override</span></span>\\n<span class=\\"line\\"><span>    public int compare(Apple a1, Apple a2) {</span></span>\\n<span class=\\"line\\"><span>        return a1.getWeight().compareTo(a2.getWeight());</span></span>\\n<span class=\\"line\\"><span>    }</span></span>\\n<span class=\\"line\\"><span>};</span></span>\\n<span class=\\"line\\"><span>//java8的比较器的声明方式</span></span>\\n<span class=\\"line\\"><span>Comparator&lt;Apple&gt; cmp=(a1,a2)-&gt;a1.getWeight().compareTo(a2.getWeight());</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}');export{c as comp,h as data};
